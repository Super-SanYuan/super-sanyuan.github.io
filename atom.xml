<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>SanYuan</title>
  
  <subtitle>一个前端er~</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-08-09T03:02:39.382Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>SanYuan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>抽象工厂模式</title>
    <link href="http://yoursite.com/2021/08/09/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/08/09/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-09T03:02:39.382Z</published>
    <updated>2021-08-09T03:02:39.382Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前情回顾"><a href="#前情回顾" class="headerlink" title="前情回顾"></a>前情回顾</h2><p>在实际的项目开发时, 我们面对的往往不是如此简单的工厂, 而是会面对多个工厂.</p><p>在简单工厂模式中, 如果我们再加入学生会干部, 就意味着我们需要修改我们的工厂函数. 长此以往, 我们的工厂函数会变得复杂臃肿.</p><p>回顾我们设计模式的<strong>开放封闭原则, 对扩展开放, 对修改封闭</strong> 而我们添加其他判断逻辑则是在修改它.</p><p>所以我们需要一个更加合理的方式来处理</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>由于抽象最初源于 Java 等强类型静态语言, 在设计初期, 往往就需要关注类型解耦. 而 JavaScript 是一个动态类型的语言, 天然具有多态性, 但目前的 JavaScript 语法里，不支持抽象类的直接实现, 所以我们只能模拟抽象类.</p><h2 id="实现一个生产手机的抽象工厂"><a href="#实现一个生产手机的抽象工厂" class="headerlink" title="实现一个生产手机的抽象工厂"></a>实现一个生产手机的抽象工厂</h2><p>一个手机生产线</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象工厂-只对类抽象的对象基本组成进行约束</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  createOs() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂创建软件系统方法, 需要重写'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  createHardware() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂创建硬件方法, 需要重写'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂-实现具体功能</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FakeStarFactory</span> <span class="keyword">extends</span> <span class="title">PhoneFactory</span> </span>&#123;</span><br><span class="line">  createOs() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> IOS()</span><br><span class="line">  &#125;</span><br><span class="line">  createHardware() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MI()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象出系统部分的抽象工厂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象手机系统工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂, 不允许直接调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体运行系统工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ios</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用ios系统方式启动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Android</span> <span class="keyword">extends</span> <span class="title">OS</span> </span>&#123;</span><br><span class="line">  run() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'用安卓系统启动'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象出硬件的抽象工厂</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象硬件类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'抽象工厂方法, 不允许直接调用'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MI</span> <span class="keyword">extends</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'使用小米硬件'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HUAWEI</span> <span class="keyword">extends</span> <span class="title">Hardware</span> </span>&#123;</span><br><span class="line">  operating() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'使用华为硬件'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开始生产手机</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> phone = <span class="keyword">new</span> FakeStarFactory() <span class="comment">// 生产手机</span></span><br><span class="line"><span class="keyword">const</span> phoneOs = phone.createOs() <span class="comment">// 加上系统</span></span><br><span class="line"><span class="keyword">const</span> phonrHardware = phone.createHardware() <span class="comment">// 加上硬件</span></span><br><span class="line">phonrHardware.operating() <span class="comment">// 选择硬件</span></span><br><span class="line">phoneOs.run() <span class="comment">// 运行系统</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前情回顾&quot;&gt;&lt;a href=&quot;#前情回顾&quot; class=&quot;headerlink&quot; title=&quot;前情回顾&quot;&gt;&lt;/a&gt;前情回顾&lt;/h2&gt;&lt;p&gt;在实际的项目开发时, 我们面对的往往不是如此简单的工厂, 而是会面对多个工厂.&lt;/p&gt;
&lt;p&gt;在简单工厂模式中, 如果我们再
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>简单工厂模式</title>
    <link href="http://yoursite.com/2021/08/09/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2021/08/09/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</id>
    <published>2021-08-09T03:02:39.382Z</published>
    <updated>2021-08-09T03:02:39.382Z</updated>
    
    <content type="html"><![CDATA[<ul><li>构造器模式</li><li>简单工厂模式</li></ul><h2 id="构造器模式-抽象每个对象的变与不变"><a href="#构造器模式-抽象每个对象的变与不变" class="headerlink" title="构造器模式-抽象每个对象的变与不变"></a>构造器模式-抽象每个对象的变与不变</h2><p>你正在开发一个学生管理系统, 开发时只有自己, 于是创建自己的用户信息:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">const</span> zhangsan = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过了两天, 你的同事过来说让你加上他的用户信息, 他要使用用户信息, 于是你:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字面量</span></span><br><span class="line"><span class="keyword">const</span> zhangsan = &#123;</span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  gender: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> lisi = &#123;</span><br><span class="line">  name: <span class="string">'李四'</span>,</span><br><span class="line">  age: <span class="number">20</span>,</span><br><span class="line">  gender: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过了两个星期,产品经理跟你说, 我这里有一点点(1000 个)测试数据, 你给我录入下, 于是你写了个构造函数(构造器)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Students</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... 此处省略读取数据, 遍历调用构造器</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Students(name, age, gender)</span><br></pre></td></tr></table></figure><h3 id="思考-变与不变"><a href="#思考-变与不变" class="headerlink" title="思考 变与不变"></a>思考 变与不变</h3><p>不变的是每个学生都有姓名、年龄、性别三个属性,这叫<strong>共性</strong><br>变化的是三个属性的值,这叫<strong>个性</strong></p><blockquote><p>案例中构造器在整个过程中就是抽象了学生这个对象, 将赋值的过程进行了封装, 确定不变的部分, 使每个学生对象都有自己的姓名、年龄、性别三个属性, 在确保不变的同时, 将变化的三个属性的值进行开放, 由用户自己传入, 保证了个性的灵活度</p></blockquote><h2 id="工厂模式-抽象不同构造器之间的变与不变"><a href="#工厂模式-抽象不同构造器之间的变与不变" class="headerlink" title="工厂模式-抽象不同构造器之间的变与不变"></a>工厂模式-抽象不同构造器之间的变与不变</h2><p>第一期交付后一个月, 学校方面打来电话, 表示要对学生中的班干部进行区分, 备注班干部职责, 于是你加了一个班干部的构造器用来生成班干部的信息,</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Students</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 普通学生</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">  <span class="keyword">this</span>.identity = <span class="string">'student'</span></span><br><span class="line">  <span class="keyword">this</span>.duties = [<span class="string">'学习'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cadres</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 班干部</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = genger</span><br><span class="line">  <span class="keyword">this</span>.identity = <span class="string">'cadre'</span></span><br><span class="line">  <span class="keyword">this</span>.duties = [<span class="string">'点名'</span>,<span class="string">'出黑板报'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时候, 你发现又出现了 <strong>变数</strong> identity, 你还需要一个方法来判断调用哪一个构造器</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name, age, gender, identity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span>(identity) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'student'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Students(name, age, gender)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cadre'</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Cadres(name, age, gender)</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="comment">// 此处省略无数个班干部</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写完后, 你发现每类班干部职责实在太多了, 难道要写几十个构造器么</p><h3 id="重新思考-变与不变"><a href="#重新思考-变与不变" class="headerlink" title="重新思考 变与不变"></a>重新思考 变与不变</h3><p>在我们的学生与班干部两个构造器中, 都拥有不变的姓名、年龄、性别三个共性, 变化是的身份与职责, 由此可以看出我们的问题, 共性封装不够、共性与个性分离不彻底, 于是我们重新封装下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, gender, identity, duties</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line">  <span class="keyword">this</span>.gender = gender</span><br><span class="line">  <span class="keyword">this</span>.identity = identity</span><br><span class="line">  <span class="keyword">this</span>.duties = duties</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Factory</span>(<span class="params">name, age, gender, identity</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> duties</span><br><span class="line">  <span class="keyword">switch</span>(identity)&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'student'</span>:</span><br><span class="line">      duties = [<span class="string">'学习'</span>,<span class="string">'做作业'</span>]</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">'cadre'</span>:</span><br><span class="line">      duties = [<span class="string">'组织活动'</span>,<span class="string">'点名'</span>]</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Student(name, age, gender, identity, duties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code>工厂模式就是对创建对象的过程进行封装, 我们不需要在关心封装内做的事情,只需要拿到工厂交付给我们的结果即可.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;构造器模式&lt;/li&gt;
&lt;li&gt;简单工厂模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;构造器模式-抽象每个对象的变与不变&quot;&gt;&lt;a href=&quot;#构造器模式-抽象每个对象的变与不变&quot; class=&quot;headerlink&quot; title=&quot;构造器模式-抽象每个对象的变与不
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式概况</title>
    <link href="http://yoursite.com/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%86%B5/"/>
    <id>http://yoursite.com/2021/08/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E5%86%B5/</id>
    <published>2021-08-09T03:02:39.382Z</published>
    <updated>2021-08-09T03:02:39.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><blockquote><p>软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性、程序的重用性。</p></blockquote><blockquote><p>设计模式是一套现成的工具, 拿来即可用. 就像电饭锅、洗衣机, 不用关心电饭锅、洗衣机的制作原理, 只需将需要的特定事物放入, 即可得到想要的结果.</p></blockquote><h2 id="JavaScript-主要设计原则–面向对象编程和面向对象设计"><a href="#JavaScript-主要设计原则–面向对象编程和面向对象设计" class="headerlink" title="JavaScript 主要设计原则–面向对象编程和面向对象设计"></a>JavaScript 主要设计原则–面向对象编程和面向对象设计</h2><ul><li>单一功能原则</li><li>开放封闭原则</li></ul><h2 id="核心思想–封装变化"><a href="#核心思想–封装变化" class="headerlink" title="核心思想–封装变化"></a>核心思想–封装变化</h2><p>一个简单的产品流程节点可以分为:</p><pre><code>想法 -&gt; 需求 -&gt; 设计 -&gt; 开发 -&gt; 测试 -&gt; 部署 -&gt; 产品</code></pre><p>&nbsp;&nbsp;通过上面的关键节点可以看出, 影响一个产品的复杂程度的主要节点是需求与设计, 在抛开个人能力不谈的时候, 设计的复杂程度取决于需求的复杂程度, 所以我们可以说需求是一个产品复杂程度的”罪魁祸首”, 而需求对于开发人员来说, 往往就是<strong>变化</strong></p><p>在实际开发过中, 我们需要做的就是将变化造成的影响 <strong>最小化</strong>.</p><pre><code>-- 将变与不变分离, 保证变化部分的灵活性, 保证不变部分的稳定性.</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;软件设计模式（Design pattern），又称设计模式，是一套被反复使用、多数人知晓的、经过分
      
    
    </summary>
    
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTML meta标签详解</title>
    <link href="http://yoursite.com/2021/08/09/meta%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2021/08/09/meta%E8%AF%A6%E8%A7%A3/</id>
    <published>2021-08-09T03:02:39.370Z</published>
    <updated>2021-08-09T03:02:39.370Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;  H5标准声明，使用 HTML5 doctype，不区分大小写</span><br><span class="line">&lt;head lang=”en”&gt; 标准的 lang 属性写法</span><br><span class="line">&lt;meta charset=’utf<span class="number">-8</span>′&gt;    声明文档使用的字符编码</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge,chrome=<span class="number">1</span>″/&gt;   优先使用 IE 最新版本和 Chrome</span><br><span class="line">&lt;meta name=”description” content=”不超过<span class="number">150</span>个字符”/&gt;       页面描述</span><br><span class="line">&lt;meta name=”keywords” content=””/&gt;      页面关键词</span><br><span class="line">&lt;meta name=”author” content=”name, email@gmail.com”/&gt;    网页作者</span><br><span class="line">&lt;meta name=”robots” content=”index,follow”/&gt;      搜索引擎抓取</span><br><span class="line">&lt;meta name=”viewport” content=”initial-scale=<span class="number">1</span>, maximum-scale=<span class="number">3</span>, minimum-scale=<span class="number">1</span>, user-scalable=no”&gt; 为移动设备添加 viewport</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-title” content=”标题”&gt; iOS 设备 begin</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-capable” content=”yes”/&gt;  添加到主屏后的标题（iOS <span class="number">6</span> 新增）</span><br><span class="line">是否启用 WebApp 全屏模式，删除苹果默认的工具栏和菜单栏</span><br><span class="line">&lt;meta name=”apple-itunes-app” content=”app-id=myAppStoreID, affiliate-data=myAffiliateData, app-argument=myURL”&gt;</span><br><span class="line">添加智能 App 广告条 Smart App Banner（iOS <span class="number">6</span>+ Safari）</span><br><span class="line">&lt;meta name=”apple-mobile-web-app-status-bar-style” content=”black”/&gt;</span><br><span class="line">&lt;meta name=”format-detection” content=”telphone=no, email=no”/&gt;  设置苹果工具栏颜色</span><br><span class="line">&lt;meta name=”renderer” content=”webkit”&gt;  启用<span class="number">360</span>浏览器的极速模式(webkit)</span><br><span class="line">&lt;meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt;     避免IE使用兼容模式</span><br><span class="line">&lt;meta http-equiv=”Cache-Control” content=”no-siteapp” /&gt;    不让百度转码</span><br><span class="line">&lt;meta name=”HandheldFriendly” content=”<span class="literal">true</span>”&gt;     针对手持设备优化，主要是针对一些老的不识别viewport的浏览器，比如黑莓</span><br><span class="line">&lt;meta name=”MobileOptimized” content=”<span class="number">320</span>″&gt;   微软的老式浏览器</span><br><span class="line">&lt;meta name=”screen-orientation” content=”portrait”&gt;   uc强制竖屏</span><br><span class="line">&lt;meta name=”x5-orientation” content=”portrait”&gt;    QQ强制竖屏</span><br><span class="line">&lt;meta name=”full-screen” content=”yes”&gt;              UC强制全屏</span><br><span class="line">&lt;meta name=”x5-fullscreen” content=”<span class="literal">true</span>”&gt;       QQ强制全屏</span><br><span class="line">&lt;meta name=”browsermode” content=”application”&gt;   UC应用模式</span><br><span class="line">&lt;meta name=”x5-page-mode” content=”app”&gt;    QQ应用模式</span><br><span class="line">&lt;meta name=”msapplication-tap-highlight” content=”no”&gt;    windows phone 点击无高光</span><br><span class="line">设置页面不缓存</span><br><span class="line">&lt;meta http-equiv=”pragma” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”cache-control” content=”no-cache”&gt;</span><br><span class="line">&lt;meta http-equiv=”expires” content=”<span class="number">0</span>″&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
    
      <category term="HTML" scheme="http://yoursite.com/categories/HTML/"/>
    
    
  </entry>
  
  <entry>
    <title>Hexo + Next + GitHub 搭建博客</title>
    <link href="http://yoursite.com/2021/08/09/hello-blog/"/>
    <id>http://yoursite.com/2021/08/09/hello-blog/</id>
    <published>2021-08-09T03:02:39.368Z</published>
    <updated>2021-08-09T03:02:39.368Z</updated>
    
    <content type="html"><![CDATA[<p>&emsp;&emsp;秃头一族怎么能没有自己的 Blog 呢? 本想着自己买服务器与域名,使用 Node React 纯手撸 ,奈何钱包与时间它不允许, 所以就有了本站与这篇文章了.</p><blockquote><p>相关链接</p></blockquote><p><a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 文档</a><br><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">NexT 文档</a><br><a href="https://cuiqingcai.com/7625.html" target="_blank" rel="noopener">参考大神博客</a></p><blockquote><p>一.全局安装 Hexo</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><blockquote><p>二.创建博客项目</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用终端进入准备存放博客项目的目录 输入以下命令</span></span><br><span class="line">hexo init hexo-blog <span class="comment"># hexo-blog 自己取名即可</span></span><br><span class="line"><span class="built_in">cd</span> hexo-blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><blockquote><p>三.本地预览博客</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server <span class="comment"># 使用浏览器开大 http://localhost:4000 即可</span></span><br></pre></td></tr></table></figure><blockquote><p>四.打包部署</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&amp;emsp;&amp;emsp;秃头一族怎么能没有自己的 Blog 呢? 本想着自己买服务器与域名,使用 Node React 纯手撸 ,奈何钱包与时间它不允许, 所以就有了本站与这篇文章了.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关链接&lt;/p&gt;
&lt;/blockquote&gt;
&lt;
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Blog" scheme="http://yoursite.com/tags/Blog/"/>
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>service-mySql篇</title>
    <link href="http://yoursite.com/2020/05/13/service-mySql%E7%AF%87/"/>
    <id>http://yoursite.com/2020/05/13/service-mySql%E7%AF%87/</id>
    <published>2020-05-13T14:44:08.000Z</published>
    <updated>2021-08-09T03:02:39.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySql"><a href="#MySql" class="headerlink" title="MySql"></a>MySql</h1><p>MySQL 是一个关系型数据库，使用 SQL 语言进行增删改查操作，目前属于 Oracle 旗下的产品。</p><p>MySQL 数据库开源免费，能够跨平台，支持分布式，性能也不错，可以和 PHP、Java 等 Web 开发语言完美配合，非常适合中小型企业作为 Web 数据库（网站数据库）</p><h2 id="Docker-安装-MySql"><a href="#Docker-安装-MySql" class="headerlink" title="Docker 安装 MySql"></a>Docker 安装 MySql</h2><p>进入 <a href="https://hub.docker.com/_/mysql" target="_blank" rel="noopener">docker hub</a> 可以看到 mysql 镜像</p><p>通过 <code>docker search</code> 的命令可以查看 mysql 的可用版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-01.png" alt="search mysql"></p><h2 id="拉取-MySql-镜像"><a href="#拉取-MySql-镜像" class="headerlink" title="拉取 MySql 镜像"></a>拉取 MySql 镜像</h2><p>通过 <code>docker pull</code> 命令拉取官方的最新版本镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull mysql:latest</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-02.png" alt="search mysql"></p><h2 id="查看本地镜像"><a href="#查看本地镜像" class="headerlink" title="查看本地镜像"></a>查看本地镜像</h2><p>通过 <code>docker images</code> 查看本地镜像, 通过 <code>TAG</code> 我们可以看到 mysql 最新版镜像已经安装成功</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-03.png" alt="search mysql"></p><h2 id="运行容器"><a href="#运行容器" class="headerlink" title="运行容器"></a>运行容器</h2><p>安装完成后, 我们可以通过 <code>docker run</code> 命令来运行 mysql 容器</p><p>通过 <code>docker ps</code> 查看 mysql 容器是否在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p 3306:3306: 映射容器服务的3306端口到宿主机的3306端口, 让外部可以直接通过 宿主机ip:3306 访问到 MySql 服务</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> MYSQL_ROOT_PASSWORD=123456：设置 MySQL 服务 root 用户的密码。</span></span><br><span class="line">docker run -itd --name mysql-official-website -p 3306:3306 -e MYSQL_ROOT_PASSWORD=你的密码 mysql</span><br><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-04.png" alt="search mysql"></p><h2 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h2><h3 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h3><p>因为我的 mysql 安装在我的云服务器上, 所以需要先登录云服务器, 如果安装在本地可略过这一步</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><h3 id="进入-mysql-容器"><a href="#进入-mysql-容器" class="headerlink" title="进入 mysql 容器"></a>进入 mysql 容器</h3><p>我们可以通过 <code>docker exec</code> 命令, 进入我们在运行的 mysql 容器</p><p>通过 <code>mysql</code> 的命令进入 mysql 命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i:即使没有附加也保持STDIN 打开</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -t: 分配一个伪终端</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql-official-website: 你启动容器时候取的容器名字</span></span><br><span class="line">docker exec -it mysql-official-website bash # 进入 mysql 容器</span><br><span class="line"></span><br><span class="line">mysql -uroot -p # 进入 mysql 命令行 需要输入密码</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-05.png" alt="search mysql"></p><h2 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h2><p>通过上一步, 我们已经进入了 mysql 命令行</p><p>在 mysql 命令行, 我们可以通过 <code>CREATE DATABASE</code> 来创建数据库</p><p>通过 <code>show processlist;</code> 来查看所有库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &#96;databasename&#96; DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br><span class="line"></span><br><span class="line">show processlist;</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-06.png" alt="search mysql"></p><h2 id="一个-mysql-8-版本的-bug"><a href="#一个-mysql-8-版本的-bug" class="headerlink" title="一个 mysql 8 版本的 bug"></a>一个 mysql 8 版本的 bug</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 报错信息</span></span><br><span class="line">nodejs.ER_NOT_SUPPORTED_AUTH_MODEError: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication protocol requested by server; consider upgrading MySQL client</span><br></pre></td></tr></table></figure><p>从 MySQL8.0 开始，默认的加密规则使用的是 caching_sha2_password</p><p>进入 mysql 命令行, 依次执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看当前 root 用户的加密规则</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> use mysql;</span></span><br><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> select user, host, plugin from user</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 修改加密规则</span></span><br><span class="line">ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'password';</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/04/04-07.png" alt="search mysql"></p><h2 id="常用-mysql-命令"><a href="#常用-mysql-命令" class="headerlink" title="常用 mysql 命令"></a>常用 mysql 命令</h2><pre><code>- 退出 mysql 命令行: exit- 清空 mysql 终端: system clear</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySql&quot;&gt;&lt;a href=&quot;#MySql&quot; class=&quot;headerlink&quot; title=&quot;MySql&quot;&gt;&lt;/a&gt;MySql&lt;/h1&gt;&lt;p&gt;MySQL 是一个关系型数据库，使用 SQL 语言进行增删改查操作，目前属于 Oracle 旗下的产品。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>service-Jenkins篇</title>
    <link href="http://yoursite.com/2020/05/12/service-Jenkins%E7%AF%87/"/>
    <id>http://yoursite.com/2020/05/12/service-Jenkins%E7%AF%87/</id>
    <published>2020-05-12T14:23:39.000Z</published>
    <updated>2021-08-09T03:02:39.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>Jenkins 是一个独立的开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复的工作，旨在提供一个开放易用的软件平台，使软件的持续集成变成可能。前身是 Hudson 是一个可扩展的持续集成引擎。可用于自动化各种任务，如构建，测试和部署软件。Jenkins 可以通过本机系统包 Docker 安装，甚至可以通过安装 Java Runtime Environment 的任何机器独立运行。</p><blockquote><p><a href="https://www.jenkins.io/zh/doc/" target="_blank" rel="noopener">Jenkins 中文文档</a></p></blockquote><h2 id="安装-jenkins"><a href="#安装-jenkins" class="headerlink" title="安装 jenkins"></a>安装 jenkins</h2><blockquote><p>本文主要主要通过 Docker 对 jenkins 进行安装. 其他安装方法可以参考 Jenkins 官方文档</p></blockquote><p>打开 <a href="https://hub.docker.com/" target="_blank" rel="noopener">Docker hub</a> 搜索 jenkins (需要登录), 点击搜索结果</p><p><img data-src="../images/service-ci-cd/03/03-01.png" alt="jenkins"></p><p>进入详情页后, 往下翻, 找到 <code>How to use image</code></p><p><img data-src="../images/service-ci-cd/03/03-02.png" alt="jenkins"></p><p>根据官方提供的命令安装 jenkins</p><blockquote><p>此处我加上了一些额外参数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> docker run: 指定一个新的容器并运行一个命令</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --name: 指定容器名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -itd:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     i: 打开STDIN，用于控制台交互</span></span><br><span class="line"><span class="meta">#</span><span class="bash">     t: 分配tty设备，该可以支持终端登录，默认为<span class="literal">false</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">     d: 后台运行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 11005:8080: 指定容器暴露的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 50000:50000: 指定容器暴露的端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> jenkins/jenkins:lts: 使用 jenkins/jenkins 的长期支持版本</span></span><br><span class="line">docker run --name jenkins_ginger -itd -p 11005:8080 -p 50000:50000 jenkins/jenkins:lts</span><br></pre></td></tr></table></figure><p>如图表示安装成功, 通过 <code>docker ps</code> 也可以查看到 jenkins 正在运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/03/03-03.png" alt="Jenkins"></p><h2 id="查看-jenkins-默认密码"><a href="#查看-jenkins-默认密码" class="headerlink" title="查看 jenkins 默认密码"></a>查看 jenkins 默认密码</h2><p>通过 <code>docker logs -f jenkins_ginger</code> 可以查看到 jenkins 的日志, 从日志中, 可以获取到 jenkins 的默认密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -f: 跟踪日志输出</span></span><br><span class="line">docker log -f jenkins_ginger</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/03/03-04.png" alt="Jenkins"></p><h2 id="登录-jenkins"><a href="#登录-jenkins" class="headerlink" title="登录 jenkins"></a>登录 jenkins</h2><p>打开浏览器, 输入 <code>xx.xx.xx.xx:11005</code> 服务器公网 ip 地址加上刚刚运行时指定的 11005 端口, 就可以看到如下图所示登录页面, 输入上一步获取到的密码, 点击继续</p><p><img data-src="../images/service-ci-cd/03/03-05.png" alt="Jenkins"></p><p>点击安装推荐的插件</p><p><img data-src="../images/service-ci-cd/03/03-06.png" alt="Jenkins"></p><p>进入漫长的等待…</p><p><img data-src="../images/service-ci-cd/03/03-07.png" alt="Jenkins"></p><p>插件安装完成后, 会进入一个设置界面</p><p><img data-src="../images/service-ci-cd/03/03-08.png" alt="Jenkins"></p><p>输入账户密码, 点击继续</p><p><img data-src="../images/service-ci-cd/03/03-09.png" alt="Jenkins"></p><p>点击保存并完成</p><p><img data-src="../images/service-ci-cd/03/03-10.png" alt="Jenkins"></p><p>至此 Jenkins 就安装完成了</p><h2 id="添加清华镜像源"><a href="#添加清华镜像源" class="headerlink" title="添加清华镜像源"></a>添加清华镜像源</h2><p>jenkins 默认从国外镜像源下载镜像, 速度非常感人. 所以我们先更换源地址</p><p>点击 <code>Manage Jenkins</code> -&gt; <code>Manage Plugins</code> -&gt; <code>高级</code> -&gt; <code>升级站点</code></p><blockquote><p>清华镜像源地址: <a href="https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json</a></p></blockquote><p><img data-src="../images/service-ci-cd/03/03-11.png" alt="镜像源"></p><h2 id="添加第一个构建任务"><a href="#添加第一个构建任务" class="headerlink" title="添加第一个构建任务"></a>添加第一个构建任务</h2><p>打开 jenkins 选择创建一个新任务</p><p><img data-src="../images/service-ci-cd/03/03-12.png" alt="镜像源"></p><p>输入任务名称, 选择第一项 <code>构建一个自由风格的软件项目</code> 点击确定</p><p><img data-src="../images/service-ci-cd/03/03-13.png" alt="镜像源"></p><p>在 jenkins 首页 点击 <strong>凭证</strong> 添加凭证 选择 ssh</p><p>在本地机器上通过命令创建秘钥</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -b 4096 -C 'XXX@gmail.com'</span><br></pre></td></tr></table></figure><p>通过 cat 命令获取私钥, 放入私钥至全局凭证, 取一个容易辨识的名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  .ssh/id_rsa</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/03/03-14.png" alt="镜像源"></p><p>通过 cat 命令获取公钥, 配置到 gitlab 的部署秘钥项中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat  .ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/03/03-15.png" alt="镜像源"></p><p>打开需要进行部署的 gitlab 项目仓库, 打开仓库设置, 版本库设置, <code>Deploy Keys</code>项</p><p><img data-src="../images/service-ci-cd/03/03-16.png" alt="镜像源"></p><p>翻到下面, 找到之前配置的部署公钥, 点击 <code>Enable</code> 启用公钥</p><p><img data-src="../images/service-ci-cd/03/03-17.png" alt="镜像源"></p><p>点击仓库名, 复制仓库 SSH 地址. 回到 jenkins 打开第一步创建的构建任务, 选择配置</p><p>配置源码管理:</p><pre><code>- 在源码管理菜单找到 `Git` 项- 输入复制的仓库地址- 选择第二步加入的凭证- 选择需要读取的分支</code></pre><p><img data-src="../images/service-ci-cd/03/03-18.png" alt="镜像源"></p><p>配置构建触发器:</p><pre><code>- 选择 `Build when a change is pushed to GitLab` 项- 点开 `高级`- 点击最下面的 `Generate`- 得到一个 url 与一个 token</code></pre><p><img data-src="../images/service-ci-cd/03/03-19.png" alt="镜像源"></p><p>打开 gitlab 仓库设置 -&gt; 集成设置:</p><pre><code>- 配置链接为上一步从 jenkins 获取到的链接- 配置安全令牌为上一步从 jenkins 获取到的 token- 取消 ssl 选项- 点击增加 web 钩子</code></pre><p><img data-src="../images/service-ci-cd/03/03-20.png" alt="镜像源"></p><p>回到 jenkins -&gt; 打开构建任务 -&gt; 配置 -&gt; 选择构建 -&gt; 选择执行 shell -&gt; 输入一个 shell 命令测试下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 'Hello World'</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/03/03-21.png" alt="镜像源"></p><p>回到 gielab, 使用 <code>git clone xxxx</code> 克隆仓库到本地, 添加一个文件, 提交一个 <code>commit</code>.</p><p>就可以看到 jenkins 首页已经收到我们的任务, 并开始自动进行构建</p><h2 id="常用插件列表："><a href="#常用插件列表：" class="headerlink" title="常用插件列表："></a>常用插件列表：</h2><h3 id="权限相关"><a href="#权限相关" class="headerlink" title="权限相关"></a>权限相关</h3><ul><li>添加 Github 授权认证 <a href="https://plugins.jenkins.io/github-oauth" target="_blank" rel="noopener">GitHub Authentication</a></li><li>权限相关：<a href="https://plugins.jenkins.io/pam-auth" target="_blank" rel="noopener">PAM Authentication</a>, <a href="https://plugins.jenkins.io/matrix-auth" target="_blank" rel="noopener">Matrix Authorization Strategy</a>, <a href="https://plugins.jenkins.io/role-strategy" target="_blank" rel="noopener">Role-based Authorization Strategy</a></li></ul><h3 id="Git-相关"><a href="#Git-相关" class="headerlink" title="Git 相关"></a>Git 相关</h3><ul><li>Git 相关：<a href="https://github.com/jenkinsci/git-plugin" target="_blank" rel="noopener">Git plugin</a>, <a href="https://plugins.jenkins.io/ssh-slaves" target="_blank" rel="noopener">SSH Slaves</a>, <a href="https://plugins.jenkins.io/github" target="_blank" rel="noopener">GitHub</a>, <a href="https://wiki.jenkins-ci.org/display/JENKINS/GitLab+Plugin" target="_blank" rel="noopener">GitLab Plugin</a></li></ul><h3 id="构建相关"><a href="#构建相关" class="headerlink" title="构建相关"></a>构建相关</h3><ul><li>添加构建的选择参数 Extended Choice Parameter plugin</li><li>参数化构建 Build With Parameters Plugin</li><li>定时周期执行任务, crontab Cron Column Plugin</li><li>添加 python 支持 Python Plugin</li><li>添加构建名字 Build Name Setter Plugin</li><li>构建超时 Build-timeout Plugin</li><li>构建环境变量注入 Build Environment</li><li>构建状态：Embeddable Build Status</li><li>构建名称设置：Build Name and Description Setter</li></ul><h3 id="通知相关"><a href="#通知相关" class="headerlink" title="通知相关"></a>通知相关</h3><ul><li><p>发邮件 Mailer</p></li><li><p>邮件模板 Email Extension Template</p></li><li><p>使用绿色代替默认的蓝色表示任务运行成功的状态 Green Balls</p></li><li><p>彩色输出日志 AnsiColor Plugin</p></li><li><p>硬盘使用情况 Disk Usage</p></li><li><p>变更查询 Job Configuration History</p></li><li><p>实时的执行任务的节点名称：built-on-column</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Jenkins&quot;&gt;&lt;a href=&quot;#Jenkins&quot; class=&quot;headerlink&quot; title=&quot;Jenkins&quot;&gt;&lt;/a&gt;Jenkins&lt;/h1&gt;&lt;p&gt;Jenkins 是一个独立的开源软件项目，是基于 Java 开发的一种持续集成工具，用于监控持续重复
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>service-Docker篇</title>
    <link href="http://yoursite.com/2020/05/11/service-Docker%E7%AF%87/"/>
    <id>http://yoursite.com/2020/05/11/service-Docker%E7%AF%87/</id>
    <published>2020-05-11T13:27:49.000Z</published>
    <updated>2021-08-09T03:02:39.370Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p>Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。</p><p>Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。</p><p>容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h2 id="Docker-的应用场景"><a href="#Docker-的应用场景" class="headerlink" title="Docker 的应用场景"></a>Docker 的应用场景</h2><ul><li><p>Web 应用的自动化打包和发布。</p></li><li><p>自动化测试和持续集成、发布。</p></li><li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p></li><li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p></li></ul><h2 id="Docker-架构"><a href="#Docker-架构" class="headerlink" title="Docker 架构"></a>Docker 架构</h2><p>Docker 包括三个基本概念:</p><ul><li><p><strong>镜像</strong> (Image): Docker 镜像, 就相当于是一个 root 文件系统. 比如官方镜像 ubuntu:16.04 就包含了一套 Ubuntu16.04 最小系统的 root 文件系统</p></li><li><p><strong>容器</strong> (Container): 镜像和容器的关系, 就像面向对象程序设计中的类和实例一样, 镜像是静态的定义, 容器是镜像运行时的实体. 容器可以被创建、启动、停止、删除、暂停等</p></li><li><p><strong>仓库</strong> (Repository): 仓库可以看做一个代码控制中心, 用来保存镜像</p></li></ul><p>Docker 使用客户端-服务器 (C/S) 架构模式，使用远程 API 来管理和创建 Docker 容器。</p><p>Docker 容器通过 Docker 镜像来创建。</p><p>容器与镜像的关系类似于面向对象编程中的对象与类。</p><h2 id="CentOS7-安装-Docker"><a href="#CentOS7-安装-Docker" class="headerlink" title="CentOS7 安装 Docker"></a>CentOS7 安装 Docker</h2><h3 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h3><p>旧的 Docker 版本称为 docker 或 docker-engine 如果已经安装过这些程序, 需要先卸载以及相关依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                docker-client \</span><br><span class="line">                docker-client-latest \</span><br><span class="line">                docker-common \</span><br><span class="line">                docker-latest \</span><br><span class="line">                docker-latest-logrotate \</span><br><span class="line">                docker-logrotate \</span><br><span class="line">                docker-engine</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-01.png" alt="remove"></p><h3 id="安装-epel-更新源"><a href="#安装-epel-更新源" class="headerlink" title="安装 epel 更新源"></a>安装 epel 更新源</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y vim wget epel-release</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-02.png" alt="remove"></p><h3 id="使用-Docker-仓库进行安装"><a href="#使用-Docker-仓库进行安装" class="headerlink" title="使用 Docker 仓库进行安装"></a>使用 Docker 仓库进行安装</h3><p>在新主机上首次安装 Docker Engine-Community 之前, 需要设置 Docker 仓库. 之后可以从仓库安装和更新 Docker</p><h4 id="设置仓库"><a href="#设置仓库" class="headerlink" title="设置仓库"></a>设置仓库</h4><p>安装所需的软件包, yum-utils 提供了 yum-config-manager, 并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y yum-ytils \</span><br><span class="line">  device-mapper-persistent-data \</span><br><span class="line">  lvm2</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-03.png" alt="remove"></p><p>鉴于国内网络问题, 执行以下命令添加 yum 软件源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">  --add-repo \</span><br><span class="line">  https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-04.png" alt="remove"></p><h4 id="安装-Docker-Engine-Community"><a href="#安装-Docker-Engine-Community" class="headerlink" title="安装 Docker Engine-Community"></a>安装 Docker Engine-Community</h4><p>安装最新版本的 Docker Engine-Community 和 containerd</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install -y docker-ce docker-ce-cli containerd.io</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-05.png" alt="remove"><br><img data-src="../images/service-ci-cd/02/02-06.png" alt="remove"></p><h4 id="配置-163-镜像加速"><a href="#配置-163-镜像加速" class="headerlink" title="配置 163 镜像加速"></a>配置 163 镜像加速</h4><p>增加配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'</span><br><span class="line">&#123;  "registry-mirrors": ["http://hub-mirror.c.163.com"]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>重启 docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>安装 docker 命令补全工具</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y bash-completion</span><br></pre></td></tr></table></figure><p>设置 docker 开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/02/02-08.png" alt="remove"></p><h2 id="docker-常用命令"><a href="#docker-常用命令" class="headerlink" title="docker 常用命令"></a>docker 常用命令</h2><blockquote><p><a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">更多 Dokcer 命令</a></p></blockquote><h3 id="docker-run"><a href="#docker-run" class="headerlink" title="docker run"></a>docker run</h3><p>创建一个新的容器并运行一个命令</p><p>语法:</p><blockquote><p>docker run [OPTIONS] IMAGE [COMMAND][arg…]</p></blockquote><p>OPTIONS 说明：</p><p>-a stdin: 指定标准输入输出内容类型，可选 STDIN/STDOUT/STDERR 三项；</p><p>-d: 后台运行容器，并返回容器 ID；</p><p>-i: 以交互模式运行容器，通常与 -t 同时使用；</p><p>-P: 随机端口映射，容器内部端口随机映射到主机的高端口</p><p>-p: 指定端口映射，格式为：主机(宿主)端口:容器端口</p><p>-t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；</p><p>–name=”nginx-lb”: 为容器指定一个名称；</p><p>–dns 8.8.8.8: 指定容器使用的 DNS 服务器，默认和宿主一致；</p><p>–dns-search example.com: 指定容器 DNS 搜索域名，默认和宿主一致；</p><p>-h “mars”: 指定容器的 hostname；</p><p>-e username=”ritchie”: 设置环境变量；</p><p>–env-file=[]: 从指定文件读入环境变量；</p><p>–cpuset=”0-2” or –cpuset=”0,1,2”: 绑定容器到指定 CPU 运行；</p><p>-m :设置容器使用内存最大值；</p><p>–net=”bridge”: 指定容器的网络连接类型，支持 bridge/host/none/container: 四种类型；</p><p>–link=[]: 添加链接到另一个容器；</p><p>–expose=[]: 开放一个端口或一组端口；</p><p>–volume , -v: 绑定一个卷</p><h3 id="docker-start-stop-restart-命令"><a href="#docker-start-stop-restart-命令" class="headerlink" title="docker start/stop/restart 命令"></a>docker start/stop/restart 命令</h3><p><strong>docker start</strong> : 启动一个或多个已经被停止的容器</p><p><strong>docker stop</strong> : 停止一个运行中的容器</p><p><strong>docker restart</strong> : 重启容器</p><p>语法</p><blockquote><p>docker start [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker stop [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker restart [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>实例</p><p>启动已被停止的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start jenkins</span><br></pre></td></tr></table></figure><p>停止运行中的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop jenkins</span><br></pre></td></tr></table></figure><p>重启容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart jenkins</span><br></pre></td></tr></table></figure><h3 id="Docker-kill-命令"><a href="#Docker-kill-命令" class="headerlink" title="Docker kill 命令"></a>Docker kill 命令</h3><p>杀掉一个运行中的容器。</p><p>语法</p><blockquote><p>docker kill [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>OPTIONS 说明：</p><p>-s :向容器发送一个信号</p><p>实例</p><p>杀掉运行中的容器 jenkins</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker kill -s KILL jenkins</span><br></pre></td></tr></table></figure><h3 id="Docker-rm-命令"><a href="#Docker-rm-命令" class="headerlink" title="Docker rm 命令"></a>Docker rm 命令</h3><p>删除一个或多个容器。</p><p>语法:</p><blockquote><p>docker rm [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>OPTIONS 说明：</p><p>-f :通过 SIGKILL 信号强制删除一个运行中的容器。</p><p>-l :移除容器间的网络连接，而非容器本身。</p><p>-v :删除与容器关联的卷。</p><p>实例:</p><p>强制删除容器 db01、db02：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -f db01 db02</span><br></pre></td></tr></table></figure><p>移除容器 nginx01 对容器 db01 的连接，连接名 db：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -l db</span><br></pre></td></tr></table></figure><p>删除容器 nginx01, 并删除容器挂载的数据卷：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm -v nginx01</span><br></pre></td></tr></table></figure><p>删除所有已经停止的容器：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm \$(docker ps -a -q)</span><br></pre></td></tr></table></figure><p><strong>docker pause</strong> :暂停容器中所有的进程。</p><p><strong>docker unpause</strong> :恢复容器中所有的进程。</p><p>语法</p><blockquote><p>docker pause [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><blockquote><p>docker unpause [OPTIONS] CONTAINER [CONTAINER…]</p></blockquote><p>实例</p><p>暂停数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pause db01</span><br></pre></td></tr></table></figure><p>恢复数据库容器 db01 提供服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker unpause db01</span><br></pre></td></tr></table></figure><h3 id="Docker-ps-命令"><a href="#Docker-ps-命令" class="headerlink" title="Docker ps 命令"></a>Docker ps 命令</h3><p>列出容器</p><p>语法</p><blockquote><p>docker ps [OPTIONS]</p></blockquote><p>OPTIONS 说明：</p><p>-a :显示所有的容器，包括未运行的。</p><p>-f :根据条件过滤显示的内容。</p><p>–format :指定返回值的模板文件。</p><p>-l :显示最近创建的容器。</p><p>-n :列出最近创建的 n 个容器。</p><p>–no-trunc :不截断输出。</p><p>-q :静默模式，只显示容器编号。</p><p>-s :显示总的文件大小。</p><p>实例</p><p>列出所有在运行的容器信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入</span></span><br><span class="line">CONTAINER ID IMAGE COMMAND ... PORTS NAMES</span><br><span class="line">09b93464c2f7 nginx:latest "nginx -g 'daemon off" ... 80/tcp, 443/tcp myrunoob</span><br></pre></td></tr></table></figure><p>输出详情介绍：</p><p>CONTAINER ID: 容器 ID。</p><p>IMAGE: 使用的镜像。</p><p>COMMAND: 启动容器时运行的命令。</p><p>CREATED: 容器的创建时间。</p><p>STATUS: 容器状态。</p><p>状态有 7 种：</p><pre><code>created（已创建）restarting（重启中）running（运行中）removing（迁移中）paused（暂停）exited（停止）dead（死亡）PORTS: 容器的端口信息和使用的连接类型（tcp\udp）。</code></pre><p>NAMES: 自动分配的容器名称。</p><h3 id="Docker-logs-命令"><a href="#Docker-logs-命令" class="headerlink" title="Docker logs 命令"></a>Docker logs 命令</h3><p>获取容器的日志</p><p>语法</p><blockquote><p>docker logs [OPTIONS] CONTAINER</p></blockquote><p>OPTIONS 说明：</p><p>-f : 跟踪日志输出</p><p>–since :显示某个开始时间的所有日志</p><p>-t : 显示时间戳</p><p>–tail :仅列出最新 N 条容器日志</p><h3 id="Docker-images-命令"><a href="#Docker-images-命令" class="headerlink" title="Docker images 命令"></a>Docker images 命令</h3><p>列出本地镜像。</p><p>语法</p><blockquote><p>docker images [OPTIONS]REPOSITORY[:TAG]]</p></blockquote><p>OPTIONS 说明：</p><p>-a :列出本地所有的镜像（含中间映像层，默认情况下，过滤掉中间映像层）；</p><p>–digests :显示镜像的摘要信息；</p><p>-f :显示满足条件的镜像；</p><p>–format :指定返回值的模板文件；</p><p>–no-trunc :显示完整的镜像信息；</p><p>-q :只显示镜像 ID。</p><h3 id="Docker-commit-命令"><a href="#Docker-commit-命令" class="headerlink" title="Docker commit 命令"></a>Docker commit 命令</h3><p>从容器创建一个新的镜像。</p><p>语法</p><blockquote><p>docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p></blockquote><p>OPTIONS 说明：</p><p>-a :提交的镜像作者；</p><p>-c :使用 Dockerfile 指令来创建镜像；</p><p>-m :提交时的说明文字；</p><p>-p :在 commit 时，将容器暂停。</p><h3 id="Docker-cp-命令"><a href="#Docker-cp-命令" class="headerlink" title="Docker cp 命令"></a>Docker cp 命令</h3><p>用于容器与主机之间的数据拷贝。</p><p>语法</p><blockquote><p>docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-<br>docker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH</p></blockquote><p>OPTIONS 说明：</p><p>-L :保持源目标中的链接</p><p>Docker rmi 命令</p><p>删除本地一个或多少镜像。</p><p>语法</p><blockquote><p>docker rmi [OPTIONS] IMAGE [IMAGE…]</p></blockquote><p>OPTIONS 说明：</p><p>-f :强制删除；</p><p>–no-prune :不移除该镜像的过程镜像，默认移除；</p><p>Docker exec 命令</p><p>在运行的容器中执行命令</p><p>语法</p><blockquote><p>docker exec [OPTIONS] CONTAINER COMMAND [ARG…]</p></blockquote><p>OPTIONS 说明：</p><p>-d :分离模式: 在后台运行</p><p>-i :即使没有附加也保持 STDIN 打开</p><p>-t :分配一个伪终端</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Docker&quot;&gt;&lt;a href=&quot;#Docker&quot; class=&quot;headerlink&quot; title=&quot;Docker&quot;&gt;&lt;/a&gt;Docker&lt;/h1&gt;&lt;p&gt;Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>React-初体验</title>
    <link href="http://yoursite.com/2020/05/09/React-%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
    <id>http://yoursite.com/2020/05/09/React-%E5%88%9D%E4%BD%93%E9%AA%8C/</id>
    <published>2020-05-09T06:24:32.000Z</published>
    <updated>2021-08-09T03:02:39.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从-JS-基本语法去理解-React"><a href="#从-JS-基本语法去理解-React" class="headerlink" title="从 JS 基本语法去理解 React"></a>从 JS 基本语法去理解 React</h2><p>实现创建元素并且加入到页面进行渲染</p><p>第一版<br>实现功能:</p><ul><li>1、创建节点元素</li><li>2、元素嵌套</li><li>3、元素渲染到页面</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="built_in">document</span>.createElement(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">const</span> span = <span class="built_in">document</span>.createElement(<span class="string">'span'</span>)</span><br><span class="line">div.appendChild(p)</span><br><span class="line">p.appendChild(span)</span><br><span class="line">span.innerText = <span class="string">'我是一个span'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br></pre></td></tr></table></figure><p>第二版 代码优化:</p><ul><li>1、将重复的 document.createElement() 提取成一个函数方法</li><li>2、方法接受一个 tagName 返回创建好的元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(tagName)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> div = createElement(<span class="string">'div'</span>)</span><br><span class="line"><span class="keyword">const</span> p = createElement(<span class="string">'p'</span>)</span><br><span class="line"><span class="keyword">const</span> span = createElement(<span class="string">'span'</span>)</span><br><span class="line">div.appendChild(p)</span><br><span class="line">p.appendChild(span)</span><br><span class="line">span.innerText = <span class="string">'我是一个 span'</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(div)</span><br></pre></td></tr></table></figure><p>第三版 继续优化:</p><ul><li>1、方法接受第二个参数 参数值可以是一个元素节点 也可以是元素节点需要渲染的内容</li><li>2、将函数调用提取到一个函数方法中 返回一个组装好了子元素或内容的的元素节点</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">tagName, childer</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> parent = <span class="built_in">document</span>.createElement(tagName)</span><br><span class="line">  <span class="keyword">if</span> (childer) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> childer === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> child = <span class="built_in">document</span>.createTextNode(childer)</span><br><span class="line">      parent.appendChild(child)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      parent.appendChild(childer)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parent</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    createElement(<span class="string">'p'</span>, createElement(<span class="string">'span'</span>, <span class="string">'我是一个 span'</span>))</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'root'</span>).appendChild(render())</span><br></pre></td></tr></table></figure><h2 id="React-思想推导"><a href="#React-思想推导" class="headerlink" title="React 思想推导"></a>React 思想推导</h2><p>使用 React 实现 JS 模拟实现的最终版</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; useState &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br></pre></td></tr></table></figure><p>第一版 :暂时不考虑 render 内部实现原理</p><ul><li>通过 React.createElement 创建 节点对象</li><li>通过 ReactDom.render 渲染</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Node</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createElement(</span><br><span class="line">    <span class="string">'div'</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    React.createElement(</span><br><span class="line">      <span class="string">'p'</span>,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      React.createElement(<span class="string">'span'</span>, <span class="literal">null</span>, <span class="string">'我是 React 实现节点创建'</span>)</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">Node</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><p>第二版: 加入 JSX</p><ul><li>每次要写 React.createElement 实在太繁琐了</li><li>于是 React 提供了 JSX 语法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Node = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      &lt;span&gt;我是 React JSX 创建的节点&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>p&gt;</span><br><span class="line">  &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDom.render(&lt;Node /</span>&gt;, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>))</span><br></pre></td></tr></table></figure><h2 id="React-组件"><a href="#React-组件" class="headerlink" title="React 组件"></a>React 组件</h2><p>React 组件提供了 class 类写法与函数式组件写法</p><h3 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>第一版:</p><ul><li>事件无法传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    setN(n + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;span&gt;这是 React 函数式组件 &#123;n&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;onClick&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="函数式组件-1"><a href="#函数式组件-1" class="headerlink" title="函数式组件"></a>函数式组件</h3><p>第二版:</p><ul><li>利用闭包实现事件传参</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [n, setN] = useState(<span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">onClick</span>(<span class="params">step</span>) </span>&#123;</span><br><span class="line">    setN(n + step)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;p&gt;</span><br><span class="line">        &lt;span&gt;这是 React 函数式组件 &#123;n&#125; &lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; onClick(2)&#125;&gt;+1&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure><h3 id="class-类-组件"><a href="#class-类-组件" class="headerlink" title="class 类 组件"></a>class 类 组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props)</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">count</span>: props.count &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;p&gt;</span><br><span class="line">          &lt;span&gt;我是 React <span class="class"><span class="keyword">class</span> 类 创建的组件 </span>&#123;<span class="keyword">this</span>.state.count&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; console.log(this)&#125;&gt;this&lt;/</span>button&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">count</span>=<span class="string">&#123;1&#125;</span> /&gt;</span>, document.getElementById('root'))</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;从-JS-基本语法去理解-React&quot;&gt;&lt;a href=&quot;#从-JS-基本语法去理解-React&quot; class=&quot;headerlink&quot; title=&quot;从 JS 基本语法去理解 React&quot;&gt;&lt;/a&gt;从 JS 基本语法去理解 React&lt;/h2&gt;&lt;p&gt;实现创建元素
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>webpack-05-plugins-mode</title>
    <link href="http://yoursite.com/2020/04/26/webpack-05-plugins/"/>
    <id>http://yoursite.com/2020/04/26/webpack-05-plugins/</id>
    <published>2020-04-26T14:46:32.000Z</published>
    <updated>2021-08-09T03:02:39.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件是 webpack 的支柱功能. 插件的目的在于解决 loader 无法实现的其他事</p><h2 id="剖析"><a href="#剖析" class="headerlink" title="剖析"></a>剖析</h2><p>webpack 插件是一个具有 apply 属性的 JavaScript 对象. apply 属性会被 webpack compiler 调用, 并且 compiler 对象可在整个编译生命周期访问</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pluginName = <span class="string">'ConsoleLogOnBuildWebpackPlugin'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogOnBuildWebpackPlugin</span> </span>&#123;</span><br><span class="line">  apply(compiler) &#123;</span><br><span class="line">    compiler.hooks.run.tap(pluginName, (compilation) =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'webpack 构建过程开始！'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>compiler hook 的 tap 方法的第一个参数，应该是驼峰式命名的插件名称。建议为此使用一个常量，以便它可以在所有 hook 中复用。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>由于插件可以携带参数/选项，你必须在 webpack 配置中，向 plugins 属性传入 new 实例。</p><p>根据你的 webpack 用法，这里有多种方式使用插件。</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>) <span class="comment">//通过 npm 安装</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>) <span class="comment">//访问内置的插件</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: <span class="string">'./path/to/my/entry/file.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'my-first-webpack.bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.(js|jsx)$/</span>,</span><br><span class="line">        use: <span class="string">'babel-loader'</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(),</span><br><span class="line">    <span class="keyword">new</span> HtmlWebpackPlugin(&#123; <span class="attr">template</span>: <span class="string">'./src/index.html'</span> &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><h2 id="Node-API"><a href="#Node-API" class="headerlink" title="Node API"></a>Node API</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>) <span class="comment">//访问 webpack 运行时(runtime)</span></span><br><span class="line"><span class="keyword">const</span> configuration = <span class="built_in">require</span>(<span class="string">'./webpack.config.js'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compiler = webpack(configuration)</span><br><span class="line">compiler.apply(<span class="keyword">new</span> webpack.ProgressPlugin())</span><br><span class="line"></span><br><span class="line">compiler.run(<span class="function"><span class="keyword">function</span> (<span class="params">err, stats</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;plugins&quot;&gt;&lt;a href=&quot;#plugins&quot; class=&quot;headerlink&quot; title=&quot;plugins&quot;&gt;&lt;/a&gt;plugins&lt;/h2&gt;&lt;p&gt;插件是 webpack 的支柱功能. 插件的目的在于解决 loader 无法实现的其他事&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-04-mode</title>
    <link href="http://yoursite.com/2020/04/25/webpack-04-mode/"/>
    <id>http://yoursite.com/2020/04/25/webpack-04-mode/</id>
    <published>2020-04-25T06:46:49.000Z</published>
    <updated>2021-08-09T03:02:39.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h2><p>提供 <code>mode</code> 配置选项, 告知 webpack 使用相应的模式的内置优化</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>只在配置中提供 <code>mode</code> 选项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  mode: <span class="string">'production'</span>, <span class="comment">// 生产环境</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者在 CLI 参数中传递</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode=production</span><br></pre></td></tr></table></figure><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><ul><li><p>development:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>development</code>. 启用 <code>NamedChunksPlugin</code> 和 <code>NamedModulesPlugin</code></p></li><li><p>production:<br>会将 <code>process.env.NODE_ENV</code> 的值设为 <code>production</code>. 启用 <code>FlagDependencyUsagePlugin</code>, <code>FlagIncludedChunksPlugin</code>, <code>ModuleConcatenationPlugin</code>, <code>NoEmitOnErrorsPlugin</code>, <code>OccurrenceOrderPlugin</code>, <code>SideEffectsFlagPlugin</code> 和 <code>UglifyJsPlugin</code>.</p></li></ul><h2 id="codes"><a href="#codes" class="headerlink" title="codes"></a>codes</h2><p>mode: development</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mode: production</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.development.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">+ mode: <span class="string">'development'</span></span><br><span class="line">- plugins: [</span><br><span class="line">-   <span class="keyword">new</span> webpack.NamedModulesPlugin(),</span><br><span class="line">-   <span class="keyword">new</span> webpack.DefinePlugin(&#123; <span class="string">"process.env.NODE_ENV"</span>: <span class="built_in">JSON</span>.stringify(<span class="string">"development"</span>) &#125;),</span><br><span class="line">- ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;模式&quot;&gt;&lt;a href=&quot;#模式&quot; class=&quot;headerlink&quot; title=&quot;模式&quot;&gt;&lt;/a&gt;模式&lt;/h2&gt;&lt;p&gt;提供 &lt;code&gt;mode&lt;/code&gt; 配置选项, 告知 webpack 使用相应的模式的内置优化&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>service-服务器篇</title>
    <link href="http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/"/>
    <id>http://yoursite.com/2020/04/25/service-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AF%87/</id>
    <published>2020-04-25T04:54:24.000Z</published>
    <updated>2021-08-09T03:02:39.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h1><p>每个程序员都应该有一台自己的云服务器</p><blockquote><p><a href="https://www.zhihu.com/question/40854395" target="_blank" rel="noopener">知乎-自己拥有一台服务器可以做哪些很酷的事情</a></p></blockquote><p>服务器厂商:</p><ul><li><a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云</a></li><li><a href="https://cn.aliyun.com/" target="_blank" rel="noopener">阿里云</a></li><li><a href="https://www.sinacloud.com/" target="_blank" rel="noopener">新浪云</a></li><li><a href="https://www.huaweicloud.com/" target="_blank" rel="noopener">华为云</a></li></ul><h2 id="购买服务器"><a href="#购买服务器" class="headerlink" title="购买服务器"></a>购买服务器</h2><blockquote><p>注: 下面流程以我自己购买的腾讯云服务器为例</p></blockquote><p>点击<a href="https://cloud.tencent.com/" target="_blank" rel="noopener">腾讯云链接</a>进入腾讯云首页, 点击右上角登录进行登录</p><p>在首页轮播图常年有活动, 新用户与学生一般是活动优惠力度最大的</p><p>点击轮播图活动进入后, 按照需求选择我们需要的服务器配置, 如果是个人学习、博客等使用, 最基本的即可</p><p><img data-src="../images/service-ci-cd/01/01-01.png" alt="服务器"></p><p>点击立即抢购之后, 跳入一个配置选择界面, 选择离自己所在地最近的城市, 选择机型配置, 选择 CentOS 系统</p><p><img data-src="../images/service-ci-cd/01/01-02.png" alt="服务器"></p><p>点击<strong>立即购买</strong>即可跳转付款页面, 核对无误后付款即可</p><h2 id="控制台"><a href="#控制台" class="headerlink" title="控制台"></a>控制台</h2><p>在腾讯云首页右上角有一个控制台按钮, 点击即可进入控制台</p><p><img data-src="../images/service-ci-cd/01/01-02.png" alt="服务器"></p><p>点击服务器后将会跳转至实例界面(如果没有实例就创建一个)</p><p><img data-src="../images/service-ci-cd/01/01-04.png" alt="实例"></p><blockquote><p>首次购买后会自动跳转至服务器控制台</p></blockquote><h2 id="登录远程服务器"><a href="#登录远程服务器" class="headerlink" title="登录远程服务器"></a>登录远程服务器</h2><blockquote><p>以 MacOS 为例</p></blockquote><p>打开终端, 输入 <code>ssh root@xx.xx.xx.xx</code> 回车</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><blockquote><p>xx.xx.xx.xx 替换为自己服务器公网 ip 地址</p></blockquote><p>弹出提示要求输入密码</p><blockquote><p>输入密码不会显示, 输入完成后直接回车即可</p></blockquote><p><img data-src="../images/service-ci-cd/01/01-05.png" alt="ssh"></p><p>如果看到如下界面就表示密码输入成功</p><p><img data-src="../images/service-ci-cd/01/01-06.png" alt="ssh"></p><p>输入 <code>cat /etc/redhat-release</code> 查看系统信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /etc/redhat-release</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/01/01-07.png" alt="ssh"></p><h2 id="配置免密验证"><a href="#配置免密验证" class="headerlink" title="配置免密验证"></a>配置免密验证</h2><p>在使用上面的命令登录远程服务器的时候, 是需要输入密码的, 而且以后每次访问都需要输入, 这样就很繁琐.</p><p>我们可以通过—ssh 免密验证</p><h3 id="在本地生成秘钥"><a href="#在本地生成秘钥" class="headerlink" title="在本地生成秘钥"></a>在本地生成秘钥</h3><p>通过如下命令在本地机器生成秘钥</p><blockquote><p>如果你使用过 git 配置, 就无需重复生成</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -t 指定加密算法； -b 指定生成的密钥长度； -C 一句话，一般都填邮箱地址。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更多参数说明可以在终端输入：ssh-keygen --<span class="built_in">help</span> 查看</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C "你的邮箱地址"</span><br></pre></td></tr></table></figure><p>这条命令执行完之后, 会提示指定公钥和私钥在本地机器上储存的位置, 因为我本地已经有秘钥了, 就从网上找了一张图</p><p><img data-src="../images/service-ci-cd/01/01-08.png" alt="ssh"></p><h3 id="将公钥储存到远程服务器主机"><a href="#将公钥储存到远程服务器主机" class="headerlink" title="将公钥储存到远程服务器主机"></a>将公钥储存到远程服务器主机</h3><p>输入以下命令, 然后回车, 将上一步我们在本地机器上生成的公钥写入服务器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> i后面接的参数是保存你公钥的文件(我们这里是.ssh/id_rsa.pub)；</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> root是远程主机的用户，这条指令会往root这个用户的主目录下的</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .ssh/authorized_keys文件写入id_rsa.pub保存的公钥</span></span><br><span class="line">ssh-copy-id -i .ssh/id_rsa.pub root@xx.xx.xx.xx</span><br></pre></td></tr></table></figure><p><img data-src="../images/service-ci-cd/01/01-09.png" alt="ssh"></p><p>根据提示, 输入服务器主机登录密码</p><p><img data-src="../images/service-ci-cd/01/01-10.png" alt="ssh"></p><p>如果看到如下提示, 表示添加成功</p><p><img data-src="../images/service-ci-cd/01/01-11.png" alt="ssh"></p><p>此时, 我们再使用 <code>ssh root@xx.xx.xx.xx</code> 对服务器进行访问, 就能直接登录, 不需要再输入密码了</p><p><img data-src="../images/service-ci-cd/01/01-12.png" alt="ssh"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;云服务器&quot;&gt;&lt;a href=&quot;#云服务器&quot; class=&quot;headerlink&quot; title=&quot;云服务器&quot;&gt;&lt;/a&gt;云服务器&lt;/h1&gt;&lt;p&gt;每个程序员都应该有一台自己的云服务器&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://www.zh
      
    
    </summary>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/categories/CI-CD/"/>
    
    
      <category term="CI&amp;CD" scheme="http://yoursite.com/tags/CI-CD/"/>
    
  </entry>
  
  <entry>
    <title>webpack-03-loader</title>
    <link href="http://yoursite.com/2020/04/22/webpack-03-loader/"/>
    <id>http://yoursite.com/2020/04/22/webpack-03-loader/</id>
    <published>2020-04-22T15:15:21.000Z</published>
    <updated>2021-08-09T03:02:39.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>loader 用于对模块的源代码进行转换. loader 可以使你在 <code>import</code> 或 “加载” 模块时预处理文件. loader 可以将文件从不同的语言转换为 JavaScript, 或将内联图像转换为 data URL, loader 甚至允许直接在 JavaScript 模块中 <code>import</code> CSS 文件</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li>loader 支持链式传递, 一组链式的 loader 按照相反的顺序执行, loader 链中的第一个 loader 返回值给下一个 loader. 在最后一个 loader 返回 webpack 所预期的 JavaScript</li><li>loader 可以是同步的, 也可以是异步的</li><li>loader 运行在 Node.js 中, 并且能够执行任何可能的操作</li><li>loader 接受查询参数, 用于对 loader 传递配置</li><li>loader 也能够使用 options 对象进行配置</li><li>除了使用 <code>package.json</code> 常见的 <code>main</code> 属性, 还可以将普通的 <code>npm</code> 模块导出为 loader, 做法是在 <code>package.json</code> 里定义一个 loader 字段</li><li>插件(plugin)可以为 loader 带来更多特性</li><li>loader 能够产生额外的任意文件</li></ul><h2 id="css-loader"><a href="#css-loader" class="headerlink" title="css-loader"></a>css-loader</h2><p>可以使用 loader 告诉 webpack 加载 CSS 文件</p><p>先安装对应的loader</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -D css-loader</span><br></pre></td></tr></table></figure><p>然后配置 <code>webpack.config.js</code> 文件, 告诉 webpack 对每个 <code>.css</code> 使用 css-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'style-loader'</span></span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">'css-loader'</span>,</span><br><span class="line">            options: <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;loader&quot;&gt;&lt;a href=&quot;#loader&quot; class=&quot;headerlink&quot; title=&quot;loader&quot;&gt;&lt;/a&gt;loader&lt;/h2&gt;&lt;p&gt;loader 用于对模块的源代码进行转换. loader 可以使你在 &lt;code&gt;import&lt;/code&gt;
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-02-入口与出口</title>
    <link href="http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/04/21/webpack-02-%E5%85%A5%E5%8F%A3%E4%B8%8E%E5%87%BA%E5%8F%A3/</id>
    <published>2020-04-21T14:58:29.000Z</published>
    <updated>2021-08-09T03:02:39.381Z</updated>
    
    <content type="html"><![CDATA[<h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口(entry)"></a>入口(entry)</h2><p><strong>入口起点</strong>(entry point)指示 webpack 应该使用哪个模块, 来作为构建其内部依赖图的开始. 进入入口后, webpack 会找出有哪些模块和库是入口起点(直接和简介)依赖的</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>entery: String|Array<string></li></ul><h3 id="CODE"><a href="#CODE" class="headerlink" title="CODE"></a>CODE</h3><p><code>entry</code> 属性的单个入口语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非简写</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    main: <span class="string">'./src/index.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>entry</code> 多入口写法 - 对象写法: </p><p>用法: `entry: {[entruChunkName: string]: string|Array<string>}</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = config</span><br></pre></td></tr></table></figure><blockquote><p>可应用于多页面程序</p></blockquote><h2 id="出口-output"><a href="#出口-output" class="headerlink" title="出口(output)"></a>出口(output)</h2><p><strong>output</strong>属性告诉 webpack 在哪里输出它所创建的 bundles, 以及如何命名这些文件, 默认值为 <code>./dist</code>. 整个应用程序结构, 都会被编译到指定的输出路径的文件夹中, </p><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>output: Object <code>output</code> 选项可以控制 webpack 如何向硬盘写入编译文件<ul><li>filename: String 打包后的文件名</li><li>path: String 打包输出路径</li></ul></li></ul><h3 id="CODE-1"><a href="#CODE-1" class="headerlink" title="CODE"></a>CODE</h3><p>单入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 借助 NodeJS 的 path 核心模块</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个入口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config = &#123;</span><br><span class="line">  entry: &#123;</span><br><span class="line">    app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">    search: <span class="string">'./src/search.js'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].js'</span>,</span><br><span class="line">    path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入到硬盘：./dist/app.js, ./dist/search.js</span></span><br></pre></td></tr></table></figure><h3 id="高级进阶"><a href="#高级进阶" class="headerlink" title="高级进阶"></a>高级进阶</h3><p>使用 CDN 和资源 hash 的复杂示例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">  path: <span class="string">'/home/proj/cnd/assets/[hash]'</span>,</span><br><span class="line">  publicPath: <span class="string">"http://cdn.example.com/assets/[hash]/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编译时不知道最终输出文件的 publicPath 的情况下，publicPath 可以留空，并且在入口起点文件运行时动态设置。如果你在编译时不知道 publicPath，你可以先忽略它，并且在入口起点设置 <strong>webpack_public_path</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__webpack_public_path__ = myRuntimePublicPath</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;入口-entry&quot;&gt;&lt;a href=&quot;#入口-entry&quot; class=&quot;headerlink&quot; title=&quot;入口(entry)&quot;&gt;&lt;/a&gt;入口(entry)&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;入口起点&lt;/strong&gt;(entry point)指示 webpack
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>webpack-01-安装与使用</title>
    <link href="http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/20/webpack-01-%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-20T13:16:47.000Z</published>
    <updated>2021-08-09T03:02:39.381Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>前提: 请确保安装了 Node.js 的最新版本</p></blockquote><h2 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h2><p>webpack 是一个现代 JavaScript 应用程序的静态模块打包器(module bundler) 当 webpack 处理应用程序时, 它会递归地构建一个依赖关系图(dependencygraph) 其中包含应用程序需要的每个模块, 然后将所有这些模块打包成一个或多个bundle</p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir webpack-dmeo # 创建项目文件夹</span><br><span class="line">cd webpack-demo # 进入项目目录</span><br><span class="line">npm init -y # 默认配置初始化</span><br></pre></td></tr></table></figure><p>出现 package.json 信息, 表示初始化成功</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两种安装"><a href="#两种安装" class="headerlink" title="两种安装"></a>两种安装</h2><h3 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g webpack</span><br></pre></td></tr></table></figure><h3 id="本地安装"><a href="#本地安装" class="headerlink" title="本地安装"></a>本地安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版本</span></span><br><span class="line">npm install --save-dev webpack </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果使用 weboack4+ 版本 还需要安装 CLI</span></span><br><span class="line">npm install --save-dev webpack-cli</span><br></pre></td></tr></table></figure><h2 id="webpack-命令使用方式"><a href="#webpack-命令使用方式" class="headerlink" title="webpack 命令使用方式"></a>webpack 命令使用方式</h2><h3 id="项目目录运行"><a href="#项目目录运行" class="headerlink" title="项目目录运行"></a>项目目录运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> webpack-demo 目录中</span></span><br><span class="line">./node_modules/.bin/webpack --sersion</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="NPM-script命令运行"><a href="#NPM-script命令运行" class="headerlink" title="NPM script命令运行"></a>NPM script命令运行</h3><p>添加 script 脚本</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"webpack-demo"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"build"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"webpack --version"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"keywords"</span>: [],</span><br><span class="line">  <span class="attr">"author"</span>: <span class="string">""</span>,</span><br><span class="line">  <span class="attr">"license"</span>: <span class="string">"ISC"</span>,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"webpack"</span>: <span class="string">"^4.42.1"</span>,</span><br><span class="line">    <span class="attr">"webpack-cli"</span>: <span class="string">"^3.3.11"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm run build</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure><h3 id="全局运行"><a href="#全局运行" class="headerlink" title="全局运行"></a>全局运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 需要全局安装webpack</span></span><br><span class="line">webpack --version</span><br><span class="line"><span class="meta">#</span><span class="bash"> ---&gt; 4.42.1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;前提: 请确保安装了 Node.js 的最新版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;webpack&quot;&gt;&lt;a href=&quot;#webpack&quot; class=&quot;headerlink&quot; title=&quot;webpack&quot;&gt;&lt;/a&gt;webpac
      
    
    </summary>
    
    
      <category term="webpack" scheme="http://yoursite.com/categories/webpack/"/>
    
    
      <category term="webpack" scheme="http://yoursite.com/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-buildFragment方法</title>
    <link href="http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/31/jQuery%E6%BA%90%E7%A0%81-buildFragment%E6%96%B9%E6%B3%95/</id>
    <published>2020-03-31T08:51:47.000Z</published>
    <updated>2021-08-09T03:02:39.368Z</updated>
    
    <content type="html"><![CDATA[<h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><p>方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts)将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><p>文档片段 DocumentFragment 表示文档的一部分, 但不属于文档树. 当把 DocumentFragment 插入文档树时, 插入的不是 DocumentFragment 自身, 而是他的所有子孙节点, 即可以一次向文档树中插入多个节点. 当需要插入大量节点时, 相比逐个插入节点, 使用 ocumentFragment 一次插入多个节点, 性能的提升会非常明显</p><p>如果 HTML 代码符合缓存条件, 方法 jQuery.buildFragment()还会把转换后的 DOM 元素缓存起来, 下次转换相同的代码时, 直接从缓存中读取, 不需要重复转换</p><h2 id="方法执行步骤"><a href="#方法执行步骤" class="headerlink" title="方法执行步骤"></a>方法执行步骤</h2><p>jQuery.buildFragment(args, nodes, scripts)执行步骤:</p><ol><li>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</li><li>创建文档片段 DocumentFragment</li><li>调用方法 jQuery.clean(elems, context, Fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</li><li>如果 HTML 代码符合缓存条件,则把转换后的 DOM 元素防褥缓存对象 jQuery.Fragments</li><li>最后返回文档片段和缓存状态 { fragment: fragment, cacheable: cacheable }</li></ol><h2 id="jQuery-buildFragment-方法源码"><a href="#jQuery-buildFragment-方法源码" class="headerlink" title="jQuery.buildFragment() 方法源码"></a>jQuery.buildFragment() 方法源码</h2><h3 id="方法定义"><a href="#方法定义" class="headerlink" title="方法定义"></a>方法定义</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.buildFragment(args, nodes, scripts) &#123;&#125;</span><br></pre></td></tr></table></figure><p>参数:</p><ul><li>ages: 数组, 含有待转换的 DOM 元素的 HTML 代码</li><li>nodes: 数组, 含有文档对象、jQuery 对象或 DOM 元素, 用于修正创建文档片段 DocumentFragment 的文档对象</li><li>scripts: 数组, 用于存放 HTML 代码中的 script 元素. 方法 jQuery.Fragment() 会把该参数传给方法 jQuery.clean(), 后者把 HTML 代码转换为 DOM 元素后, 会提取其中的 script 元素并存入数组 scrtips</li></ul><h3 id="定义局部变量-修正文档对象-doc"><a href="#定义局部变量-修正文档对象-doc" class="headerlink" title="定义局部变量, 修正文档对象 doc"></a>定义局部变量, 修正文档对象 doc</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Fragment, <span class="comment">// 指向稍后可能创建的文档片段 Document Fragment</span></span><br><span class="line">  eacheable, <span class="comment">// 表示 HTML 代码 是否符合缓存条件</span></span><br><span class="line">  eacheresults, <span class="comment">// 指向从缓存对象 jQuery.ftagment 中提取到的文档片段 包含了缓存的DOM元素</span></span><br><span class="line">  doc, <span class="comment">// 表示创建文档片段的文档对象</span></span><br><span class="line">  fitst = args[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 修正文档对象 doc</span></span><br><span class="line"><span class="comment"> * nodes 可能包含一个明确的文档对象, 也可能包含jQuery对象或DOM元素</span></span><br><span class="line"><span class="comment"> * 先尝试读取nodes[0]的属性 ownerDocuemt 并赋值给doc</span></span><br><span class="line"><span class="comment"> * 如果不存在 则假定nodes[0]为文档对象并赋值给doc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (nodes &amp;&amp; nodes[<span class="number">0</span>]) &#123;</span><br><span class="line">  doc = nodes[<span class="number">0</span>].ownerDocument || node[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查传入参数对象是不是文档对象 如果不是文档对象 而是 JavaScript 对象 就修正 doc 为当前文档对象 document</span></span><br><span class="line"><span class="keyword">if</span> (!doc.createDocumentFragment) &#123;</span><br><span class="line">  doc = <span class="built_in">document</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素"><a href="#尝试从缓存对象-jQuery-fragments-中读取缓存的-DOM-元素" class="headerlink" title="尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素"></a>尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</h3><p>如果 HTML 代码符合缓存条件, 则尝试从缓存对象 jQuery.fragments 中读取缓存的 DOM 元素</p><ul><li>数组 args 长度为 1, 且第一个元素是字符串, 即数组 args 中只有一段 HTML 代码</li><li>HTML 代码长度小于 512, 否则可能会导致缓存占用内存过大</li><li>文档对象 doc 是当前文档对象, 即之缓存为当前文档创建的 DOM 元素</li><li>HTML 代码已左尖括号开头, 即只缓存 DOM 元素, 不缓存文本节点</li><li>HTML 代码中不能含有 <code>&lt;script&gt;</code> <code>&lt;object&gt;</code> <code>&lt;embed&gt;</code> <code>&lt;option&gt;</code> <code>&lt;style&gt;</code>标签</li><li>当前浏览器可以正确的复制单选按钮核复选框的选中状态 checked, 或者 HTML 代码中的单选按钮和复选按钮没有被选中</li><li>当前浏览器可以正确的赋值 HTML5 元素, 或者 HTML 代码中不含有 HTML5 标签</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(args.length === <span class="number">1</span></span><br><span class="line">&amp;&amp; <span class="keyword">typeof</span> first === <span class="string">'string'</span></span><br><span class="line">&amp;&amp; first.length &lt; <span class="number">512</span></span><br><span class="line">&amp;&amp; doc === <span class="built_in">document</span></span><br><span class="line">&amp;&amp; first.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span></span><br><span class="line">&amp;&amp; !rnocache.test(first)</span><br><span class="line">&amp;&amp; (jQuery.support.checkClone || !rchecked.test(first))</span><br><span class="line">&amp;&amp; (jQuery.support.html5Clone || !rnshimcache.text(first))&#123;</span><br><span class="line"></span><br><span class="line">  cacheable = <span class="literal">true</span>; <span class="comment">// 如果遍历为 true 必须先赋值一份再使用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 尝试从缓存对象jQuery.fragment中读取缓存的DOM元素</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  cacheresults = jQuery.fragments[first];</span><br><span class="line">  <span class="keyword">if</span> (cacheresults &amp;&amp; cacheresults !== <span class="number">1</span>) &#123;</span><br><span class="line">    fragment = cacheresults;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jQuery.fragments = &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="转换-HTML-代码为-DOM-元素"><a href="#转换-HTML-代码为-DOM-元素" class="headerlink" title="转换 HTML 代码为 DOM 元素"></a>转换 HTML 代码为 DOM 元素</h2><p>先创建一个文档片段 DocumentFragment, 然后调用方法 jQuery.clean(elems, context, fragment, scripts) 将 HTML 代码转换为 DOM 元素, 并存储在创建的文档片段中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果为 true 表示需要直型转换过程</span></span><br><span class="line"><span class="keyword">if</span> (!fragment) &#123;</span><br><span class="line">  <span class="comment">// 调用原生方法 创建文档片段</span></span><br><span class="line">  fragment = doc.createDocumentFragment()</span><br><span class="line">  <span class="comment">// 将片段转换为 DOM 元素</span></span><br><span class="line">  jQuery.clean(args, doc, fragment, scripts)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="把转换后的-DOM-元素防褥缓存对象-jQuery-fragments"><a href="#把转换后的-DOM-元素防褥缓存对象-jQuery-fragments" class="headerlink" title="把转换后的 DOM 元素防褥缓存对象 jQuery.fragments"></a>把转换后的 DOM 元素防褥缓存对象 jQuery.fragments</h2><p>如果 HTML 代码符合缓存条件, 则把转换后的 DOM 元素放入缓存对象 jQuery.fragment 中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果符合缓存条件 就缓存</span></span><br><span class="line"><span class="keyword">if</span> (cacheable) &#123;</span><br><span class="line">  jQuery.fragments[first] = cacheresults ? fragment : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="返回文档片段和缓存状态"><a href="#返回文档片段和缓存状态" class="headerlink" title="返回文档片段和缓存状态"></a>返回文档片段和缓存状态</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  返回一个包含了文档片段 fragment 和缓存状态 cacheable 的对象</span></span><br><span class="line"><span class="comment">  fragment 中包含了转换后的 DOM 元素, 缓存状态 cacheable 则指示了如果使用这些 DOM 元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">  fragment: fragment,</span><br><span class="line">  cacheable: cacheable,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.buildFragment.png" alt="1"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;实现原理&quot;&gt;&lt;a href=&quot;#实现原理&quot; class=&quot;headerlink&quot; title=&quot;实现原理&quot;&gt;&lt;/a&gt;实现原理&lt;/h2&gt;&lt;p&gt;方法 jQuery.builfFragment(args, nodes, scripts)先创建一个文档片段 Documen
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-jQuery.fn.init</title>
    <link href="http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/"/>
    <id>http://yoursite.com/2020/03/26/jQuery%E6%BA%90%E7%A0%81-jQuery-fn-init/</id>
    <published>2020-03-26T07:29:26.000Z</published>
    <updated>2021-08-09T03:02:39.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jQuery-fn-init-selector-context-rootjQuery"><a href="#jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="jQuery.fn.init(selector, context, rootjQuery)"></a>jQuery.fn.init(selector, context, rootjQuery)</h1><p>构造函数 jQuery.fn.init() 负责解析参数 selector 和 context 的类型, 并执行相应的逻辑, 最后返回 jQuery.fn.init() 的实例.</p><blockquote><p>解析参数 selector 和 context 公有 12 个有效分支</p></blockquote><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init.png" alt="jQuery.fn.init"></p><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><h3 id="定义-jQuery-fn-init-selector-context-rootjQuery"><a href="#定义-jQuery-fn-init-selector-context-rootjQuery" class="headerlink" title="定义 jQuery.fn.init(selector, context, rootjQuery)"></a>定义 jQuery.fn.init(selector, context, rootjQuery)</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">  init: function (selector, context, rootjQuery) &#123;</span><br><span class="line">    <span class="keyword">var</span> match, elem, ret, doc</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>init()</code> 构造函数定义中接受三个参数 selector、context、rootjQuery</p><ul><li>selector: 可以是任意类型的值, 但只有 undefined、DOM 元素、字符串、函数、jQuery 对象、普通 JavaScript 对象这几种类型有效</li><li>context: 可以不传入, 或者传入 DOM 元素、jQuery 对象、普通 JavaScript 对象之一</li><li>rootjQuery: 包含了 document 对象的 jQuery 对象, 用于 document.getElementById()查找失败、selector 是选择器表达式且未指定 context、selector 是函数的情况.</li></ul><p>rootjQuery 定义与应用场景</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// document.getElementById() 查找失败</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.find(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// slector 是选择器且未指定 context</span></span><br><span class="line"><span class="keyword">return</span> (context || rootjQuery).find(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// selector 是函数</span></span><br><span class="line"><span class="keyword">return</span> rootjQuery.ready(selector)</span><br><span class="line"></span><br><span class="line"><span class="comment">// rootjQuery 定义</span></span><br><span class="line">rootjQuery = jQuery(doucment)</span><br></pre></td></tr></table></figure><h2 id="参数-selector-可以转换为-false"><a href="#参数-selector-可以转换为-false" class="headerlink" title="参数 selector 可以转换为 false"></a>参数 selector 可以转换为 false</h2><p>参数 selector 可以转换为 false, 例如: undefined、空字符串、null 等, 则直接返回 this, 此时 this 是空 jQuery 对象, 其属性 length 等于 0.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $('')、$(null) or $(undefined)</span></span><br><span class="line"><span class="keyword">if</span> (!selector) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是-DOM-元素"><a href="#参数-selector-是-DOM-元素" class="headerlink" title="参数 selector 是 DOM 元素"></a>参数 selector 是 DOM 元素</h2><p>如果参数 selector 有属性 nodeType, 则认为 selector 是 DOM 元素, 手动设置第一个元素和属性 context 指向该 DOM 元素、属性 length 为 1, 然后返回包含了该 DOM 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Handle $(DOMELement)</span></span><br><span class="line"><span class="keyword">if</span> (selector.nodeType) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="keyword">this</span>[<span class="number">0</span>] = selector</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是字符串-‘body’"><a href="#参数-selector-是字符串-‘body’" class="headerlink" title="参数 selector 是字符串 ‘body’"></a>参数 selector 是字符串 ‘body’</h2><p>如果参数 selector 是字符串 “body”, 手动设置属性 context 指向 document 对象、第一个元素指向 body 元素、属性 length 为 1, 最后返回包含了 body 元素引用的 jQuery 对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The body element only exists once, optimize finding it</span></span><br><span class="line"><span class="keyword">if</span> (selector === <span class="string">'body'</span> &amp;&amp; !context &amp;&amp; <span class="built_in">document</span>.body) &#123;</span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span></span><br><span class="line">  <span class="keyword">this</span>[<span class="number">0</span>] = <span class="built_in">document</span>.body</span><br><span class="line">  <span class="keyword">this</span>.selector = selector</span><br><span class="line">  <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是其他字符串"><a href="#参数-selector-是其他字符串" class="headerlink" title="参数 selector 是其他字符串"></a>参数 selector 是其他字符串</h2><p>如果参数 selector 是其他字符串, 则先检测 selector 是 HTML 代码还是 <code>#id</code>.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理参数是字符串</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> selector === <span class="string">'string'</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断是 HTML 代码 还是 #ID</span></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    selector.charAt(<span class="number">0</span>) === <span class="string">'&lt;'</span> &amp;&amp;</span><br><span class="line">    selector.charAt(selector.length - <span class="number">1</span>) === <span class="string">'&gt;'</span> &amp;&amp;</span><br><span class="line">    selector.length &gt;= <span class="number">3</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果是以 `&lt;` 开头 `&gt;` 结尾的  并且长度大于等于 3  跳过 正则 检查</span></span><br><span class="line">    match = [<span class="literal">null</span>, selector, mull]</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用正则检查  quickExpr = /^(?:[^#&lt;]*(&lt;[\w\W]+&gt;)[^&gt;]*$|#([\w\-]*)$)/</span></span><br><span class="line"><span class="comment">     * 依次匹配 HTML 代码和 id 如果匹配成功 match 数组第一个元素为参数 selector, 第二个元素为匹配的 HTML 代码或 undefined 第三个元素为匹配的 id 或 undefined</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('#target'); // ["#target",undefined,"target"]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;'); // ["&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;'); // ["abc&lt;div&gt;","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('abc&lt;div&gt;abc#id'); // ["abc&lt;div&gt;abc#id","&lt;div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('div'); // null</span></span><br><span class="line"><span class="comment">     * quickExpr.exec('&lt;div&gt;&lt;img&gt;&lt;/div&gt;'); // ["&lt;div&gt;&lt;img&gt;&lt;/div&gt;","&lt;div&gt;&lt;img&gt;&lt;/div&gt;",undefined]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    match = quickExpr.exec(selector)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果-selector-是单独标签"><a href="#如果-selector-是单独标签" class="headerlink" title="如果 selector 是单独标签"></a>如果 selector 是单独标签</h2><p>如果 selector 是单独标签, 就调用 document.createElement() 创建标签对应的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 检查正则匹配结果</span></span><br><span class="line"><span class="comment"> * 如果 match[1] 不是 undefined 即 selector 是 HTML 代码 或者 match[2] 不是 undefined, 即参数 selector 是 #id 并且未传入 context</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (match &amp;&amp; (match[<span class="number">1</span>] || !context)) &#123;</span><br><span class="line">  <span class="comment">// HANDLE: $(html) -&gt; $(array)</span></span><br><span class="line">  <span class="keyword">if</span> (match[<span class="number">1</span>]) &#123;</span><br><span class="line">    context = context <span class="keyword">instanceof</span> jQuery ? context[<span class="number">0</span>] : context</span><br><span class="line"></span><br><span class="line">    doc = context ? context.ownerDocument || context : <span class="built_in">document</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果传入单个字符 并且是个单标签 直接创建 跳过其他</span></span><br><span class="line">    <span class="comment">// rsingleTag = /^&lt;(\w+)\s*\/?&gt;(?:&lt;\/\1&gt;)?$/,</span></span><br><span class="line">    ret = rsingleTag.exec(selector)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret) &#123;</span><br><span class="line">      <span class="comment">// jQuery.isPlainObject() 用于检测对象是否是纯粹的对象 即用对象直接量 &#123;&#125; 或者 new Object() 创建的对象</span></span><br><span class="line">      <span class="keyword">if</span> (jQuery.isPlainObject(context)) &#123;</span><br><span class="line">        selector = [<span class="built_in">document</span>.createElement(ret[<span class="number">1</span>])]</span><br><span class="line">        <span class="comment">// attr() 遇到特殊属性和事件类型时会执行同名 jQuery 方法</span></span><br><span class="line">        jQuery.fn.attr.call(selector, context, <span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        selector = [doc.createElement(res[<span class="number">1</span>])]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>之所以把创建的 DOM 源码放入数组中, 是为了后面方便的调用 jQuery.merge() 方法, 此方法用于合并两个数组的元素到一个数组</p></blockquote><h2 id="参数-selector-是复杂-HTML-代码"><a href="#参数-selector-是复杂-HTML-代码" class="headerlink" title="参数 selector 是复杂 HTML 代码"></a>参数 selector 是复杂 HTML 代码</h2><p>如果参数 selector 是复杂 HTML 代码, 则利用浏览器 innerHTML 创建 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建过程由 buildFragment 和 clean 实现</span></span><br><span class="line"><span class="comment">    * buildFragment 返回 -&gt; &#123; fragment: 含有转换后的 DOM 元素的文档片段 , cacheable: HTML代码是否满足缓存条件&#125;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   ret = jQuery.buildFragment([ match[<span class="number">1</span>] ], [ doc ])</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 如果满足缓存条件, 在使用前 先复制一份</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   selector = (ret.cacheable ? jQuery.clone(ret.fragment): rest.fragment).childNodes</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 将创建的 DOM 元素 合并到当前 jQuery 对象中返回</span></span><br><span class="line"> <span class="keyword">return</span> jQuery.merage(<span class="keyword">this</span>, selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-id-且未指定参数-context"><a href="#如果参数-selector-是-id-且未指定参数-context" class="headerlink" title="如果参数 selector 是 #id, 且未指定参数 context"></a>如果参数 selector 是 <code>#id</code>, 且未指定参数 context</h2><p>如果参数 selector 是 <code>#id</code>, 且未指定参数 context, 则调用 document.getElementById() 查找含有指定 id 属性的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 查找含有指定 id 属性的 DOM 元素</span></span><br><span class="line">  elem = <span class="built_in">document</span>.getElementById(mathc[<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (elem &amp;&amp; elem.parentNode) &#123;</span><br><span class="line">    <span class="comment">// 检查 id 是否相等</span></span><br><span class="line">    <span class="keyword">if</span> (elem.id !== match[<span class="number">2</span>]) &#123;</span><br><span class="line">      <span class="keyword">return</span> rootjQuery.find(selector)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.length = <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>[<span class="number">0</span>] = elem</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.context = <span class="built_in">document</span></span><br><span class="line">  <span class="keyword">this</span>.selector = selector</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是选择器表达式"><a href="#参数-selector-是选择器表达式" class="headerlink" title="参数 selector 是选择器表达式"></a>参数 selector 是选择器表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HANDLE: $(expr, $(...))</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!context || context.jquery) &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 如果执行了上下文 且上下文是 jQuery 对象 执行 context.find() 方法</span></span><br><span class="line"><span class="comment">   * 如果没有指定上下文 就执行 rootjQuery.find()</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">return</span> (context || rootjQuery).find(selector);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// HANDLE: $(expr, context)</span></span><br><span class="line">  <span class="comment">// (which is just equivalent to: $(context).find(expr)</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 如果指定了上下文 但上下文不是jQuery对象 则执行方法先创建一个包含 context 的 jQuery 对象, 然后调用 find() 方法</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.constructor(context).find(selector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是函数"><a href="#参数-selector-是函数" class="headerlink" title="参数 selector 是函数"></a>参数 selector 是函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果是函数 就绑定 ready 事件</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (jQuery.isFunction(selector))&#123;</span><br><span class="line">  <span class="keyword">return</span> rootjQuery.ready(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如果参数-selector-是-jQuery-对象"><a href="#如果参数-selector-是-jQuery-对象" class="headerlink" title="如果参数 selector 是 jQuery 对象"></a>如果参数 selector 是 jQuery 对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果参数包含 selector 就认为是 jQuery 对象</span></span><br><span class="line"><span class="keyword">if</span> (selector.selector !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="comment">// 复制他的属性 selector 和 context</span></span><br><span class="line">  <span class="keyword">this</span>.selector = selector.selector</span><br><span class="line">  <span class="keyword">this</span>.context = selector.context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参数-selector-是任意其他值"><a href="#参数-selector-是任意其他值" class="headerlink" title="参数 selector 是任意其他值"></a>参数 selector 是任意其他值</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果 selector 是数组或伪数组, 则添加到当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果 selector 是 JavaScript 对象, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 如果是其他类型的值, 则作为第一个元素放入当前 jQuery 对象中</span></span><br><span class="line"><span class="comment"> * 最后返回当前 jQuery 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">return</span> jQuery.makeArray(selector, <span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p><img data-src="../images/jQuery-source-code/02%E6%9E%84%E9%80%A0jQuery%E5%AF%B9%E8%B1%A1/jQuery.fn.init_.png" alt="jQuery.fn.init_"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jQuery-fn-init-selector-context-rootjQuery&quot;&gt;&lt;a href=&quot;#jQuery-fn-init-selector-context-rootjQuery&quot; class=&quot;headerlink&quot; title=&quot;jQuery.f
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery源码结构</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84/</id>
    <published>2020-03-25T07:54:10.000Z</published>
    <updated>2021-08-09T03:02:39.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造-jQuery-对象的总体源码结构"><a href="#构造-jQuery-对象的总体源码结构" class="headerlink" title="构造 jQuery 对象的总体源码结构"></a>构造 jQuery 对象的总体源码结构</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自调用匿名函数</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构造 jQuery</span></span><br><span class="line">  <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 返回 jQuery.fn.init 的实例</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 定义一堆变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 覆盖构造函数 jQuery() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn = jQuery.protottype = &#123;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 覆盖原型对象的属性 constructor</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="keyword">constructor</span>: jQuery,</span><br><span class="line">      /**</span><br><span class="line">       * 定义原型方法 负责解析 selector 和 context 的类型并执行相应的查找</span><br><span class="line">      */</span><br><span class="line">      init: function(selector, context, rootjQuery) &#123;</span><br><span class="line">        <span class="comment">// ... 一堆原型属性和方法</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用 jQuery 构造函数的原型对象 jQuery.fn 覆盖 jQuery.fn.init() 的原型对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.fn.init.prototype = jQuery.fn;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 合并两个或多个对象的属性到第一个对象</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend = jQuery.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 执行 jQuery.extend() 在jQuery构造器上定义了一堆静态属性和方法</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    jQuery.extend(&#123;</span><br><span class="line">      <span class="comment">// 一堆静态属性和方法</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回 jQuery 构造函数并赋值给外层变量 jQuery</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">  &#125;)();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 把 jQuery 、 $ 暴露给全局作用域 window</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><h2 id="为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例"><a href="#为什么要在构造函数-jQuery-内部用运算符-new-创建并返回另一个构造函数的实例" class="headerlink" title="为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例"></a>为什么要在构造函数 jQuery()内部用运算符 new 创建并返回另一个构造函数的实例</h2><p>如果构造函数有返回值, 运算符 new 所创建的对象会被丢弃, 返回值将作为 new 表达式的值</p><p>jQuery 利用这一特性, 通过在构造函数 jQuery() 内部用运算符 new 创建并返回另一个构造函数的实例, 省去构造函数 jQuery() 前面的运算符 new</p><h2 id="为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么执行-jQuery-fn-jQuery-prototype-设置-jQuery-fn-指向构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype"></a>为什么执行 jQuery.fn = jQuery.prototype, 设置 jQuery.fn 指向构造函数 jQuery() 的原型对象 jQuery.prototype</h2><p>jQuery.fn 是 jQuery.prototype 的简写, 方便拼写</p><h2 id="jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性"><a href="#jQuery-构造函数返回的-jQuery-对象实际是-jQuery-fn-init-的实例-为什么能够在-jQuery-fn-init-的实例上调用构造函数-jQuery-的原型方法和属性" class="headerlink" title="jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性"></a>jQuery() 构造函数返回的 jQuery 对象实际是 jQuery.fn.init() 的实例, 为什么能够在 jQuery.fn.init() 的实例上调用构造函数 jQuery()的原型方法和属性</h2><p>用 jQuery()构造函数的原型对象覆盖了构造函数 jQuery.fn.init()的原型对象, 从而使得 jQuery.fn.init() 的实例也可以访问 jQuery()构造函数的原型方法核属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.init.prototype = jQuery.fn;</span><br></pre></td></tr></table></figure><h2 id="为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中"><a href="#为什么在构造-jQuery-构造函数的时候-要包裹在一个自调用匿名函数中" class="headerlink" title="为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中"></a>为什么在构造 jQuery()构造函数的时候, 要包裹在一个自调用匿名函数中</h2><p>在自调用安徽省农户中定义了很多其他局部变量, 这些局部变量只在 jQuery 对象内部使用, 使用自调用匿名函数可以减少与其他模块的耦合度</p><h2 id="为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype"><a href="#为什么要覆盖构造函数-jQuery-的原型对象-jQuery-prototype" class="headerlink" title="为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype"></a>为什么要覆盖构造函数 jQuery()的原型对象 jQuery.prototype</h2><p>在原型对象 jQuery.prototype 上定义的属性和方法会被所有 jQuery 对象继承，可以有效减少每个 jQuery 对象所需的内存。事实上，jQuery 对象只包含 5 种非继承属性，其余都继承自原型对象 jQuery.prototype；在构造函数 jQuery.fn.init()中设置了整型属性、length、selector、context；在原型方法.pushStack()中设置了 prevObject。因此，也不必因为 jQuery 对象带有太多的属性和方法而担心会占用太多的内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造-jQuery-对象的总体源码结构&quot;&gt;&lt;a href=&quot;#构造-jQuery-对象的总体源码结构&quot; class=&quot;headerlink&quot; title=&quot;构造 jQuery 对象的总体源码结构&quot;&gt;&lt;/a&gt;构造 jQuery 对象的总体源码结构&lt;/h1&gt;&lt;figu
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-构造函数jQuery</title>
    <link href="http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/"/>
    <id>http://yoursite.com/2020/03/25/jQuery%E6%BA%90%E7%A0%81-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0jQuery/</id>
    <published>2020-03-25T07:51:57.000Z</published>
    <updated>2021-08-09T03:02:39.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="构造函数-jQuery"><a href="#构造函数-jQuery" class="headerlink" title="构造函数 jQuery"></a>构造函数 jQuery</h1><p>构造函数 jQuery 有七种用法:</p><ul><li>jQuery(select [,context]): 接受一个 CSS 选择器表达式和可选的选择器上下文, 返回一个包含了匹配的 DOM 元素的 jQuery 对象</li><li>jQuery(html,[, ownerDocument])、jQuery(html, props): 用提供的 HTML 代码创建 DOM 元素</li><li>jQuery(element)、jQuery(elementArray): 封装 DOM 元素为 jQuery 对象</li><li>jQuery(object): 封装普通对象为 jQuery 对象</li><li>jQuery(callback): 绑定 ready 事件监听函数, 当 DOM 结构加载完成时执行</li><li>jQuery(jQuery object): 接受一个 jQuery 对象, 返回该 jQuery 对象的拷贝副本</li><li>jQuery(): 创建一个 jQuery 对象</li></ul><h2 id="jQuery-select-context"><a href="#jQuery-select-context" class="headerlink" title="jQuery(select [,context])"></a>jQuery(select [,context])</h2><p>如果传入一个字符串参数, jQuery 会检查这个字符串是选择器表达式还是 HTML 代码. 如果是选择器表达式, 则遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象. 如果没有元素与之匹配, 则创建一个空 jQuery 对象, 其中不包含任何元素, 其属性 length 等于 0.</p><p>默认情况下, 对匹配元素的查找将从根元素 document 对象开始, 即查找范围是整个文档树, 不过也可以传入第二个参数 context 来限定查找范围</p><p>如果选择器表达式 selector 是简单的 <code>#id</code>, 且没有指定上下文 context, 则调用浏览器原生方法 document.getElementById() 查找属性 id 等于指定值的元素; 如果是比 <code>#id</code> 复杂的选择器表达式或指定了上下文, 则通过 jQuery 方法 <code>.find()</code> 查找, 因此 <code>$(&#39;span&#39;, this)</code> 等价于 <code>$(this).find(&#39;span&#39;)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'#app'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $('span', this).html(222);</span></span><br><span class="line">  $(<span class="keyword">this</span>)</span><br><span class="line">    .find(<span class="string">'span'</span>)</span><br><span class="line">    .html(<span class="string">'find'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-html-ownerDocument-、jQuery-html-props"><a href="#jQuery-html-ownerDocument-、jQuery-html-props" class="headerlink" title="jQuery(html [,ownerDocument])、jQuery(html, props)"></a>jQuery(html [,ownerDocument])、jQuery(html, props)</h2><h3 id="第一个参数"><a href="#第一个参数" class="headerlink" title="第一个参数"></a>第一个参数</h3><p>如果传入的字符串参数看起来像一段 HTML 代码, jQuery 则尝试用这段 HTML 代码创建新的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;button&gt;CLICK ME&lt;/button&gt;'</span>).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><p>如果 HTML 代码是一个单独标签, jQuery 会使用浏览器原生方法 document.createElement() 创建 DOM 元素</p><p>如果是多层嵌套 HTML 片段, 则利用浏览器的 innerHTML 机制创建 DOM 元素, 这个过程由 <code>jQuery.buildFragment()</code> 和 <code>jQuery.clean()</code> 实现</p><h3 id="第二个参数"><a href="#第二个参数" class="headerlink" title="第二个参数"></a>第二个参数</h3><p>ownerDocument 用于指定创建新 DOM 元素的文档对象, 如果不传入, 则默认为当前文档对象</p><p>如果 HTML 代码是一个单独标签, 那么第二个参数还可以是 props, props 是一个包含了属性、事件的普通对象; 在调用 document.createElement() 创建 DOM 元素后, 参数 props 会被传给 jQuery 方法 <code>.attr()</code>, 然后由 <code>.attr()</code> 负责把 props 中的属性、事件设置到新穿创建的 DOM 元素上</p><p>参数 props 的属性可以是任意的事件类型（如”click”），此时属性值应该是事件监听函数，它将被绑定到新创建的 DOM 元素上；参数 props 可以含有以下特殊属性：val、css、html、text、data、width、height、offset，相应的 jQuery 方法：<code>.val()</code>、<code>.css()</code>、<code>.html()</code>、<code>.text()</code>、<code>.data()</code>、<code>.width()</code>、<code>.height()</code>、`.offset()将被执行，并且属性值会作为参数传入；其他类型的属性则会被设置到新创建的 DOM 元素上，某些特殊属性还会做跨浏览器兼容（如 type、value、tabindex 等）；可以通过属性名 class 设置类样式，但要用引号把 class 包裹起来，因为 class 是 JavaScript 保留字。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'&lt;div /&gt;'</span>, &#123;</span><br><span class="line">  text: <span class="string">'哈哈'</span>,</span><br><span class="line">  class: 'active',</span><br><span class="line">  click: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log((<span class="keyword">this</span>.innerHTML = <span class="string">'嘻嘻'</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;).appendTo(<span class="string">'body'</span>);</span><br></pre></td></tr></table></figure><h2 id="jQuery-element-、jQuery-elementArray"><a href="#jQuery-element-、jQuery-elementArray" class="headerlink" title="jQuery(element)、jQuery(elementArray)"></a>jQuery(element)、jQuery(elementArray)</h2><p>如果传入一个 DOM 元素或 DOM 元素数组, 则把 DOM 元素封装到 jQuery 对象中并返回</p><p>这个功能常见于事件监听函数, 即把关键字 this 因用那个的 DOM 元素封装为 jQuery 对象, 然后在该 jQuery 对象上调用 jQuery 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'div'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  $(<span class="keyword">this</span>).slideUp();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-object"><a href="#jQuery-object" class="headerlink" title="jQuery(object)"></a>jQuery(object)</h2><p>如果传入一个普通 JavaScript 对象, 则把该对象封装到 jQuery 对象中并返回</p><p>这个功能可以方便的在普通 JavaScript 对象上实现自定义事件的绑定和触发</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $foo = $(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span>, <span class="attr">hello</span>: <span class="string">'worldd'</span> &#125;);</span><br><span class="line">$foo.on(<span class="string">'custom'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.foo);</span><br><span class="line">&#125;);</span><br><span class="line">$foo.trigger(<span class="string">'custom'</span>); <span class="comment">// -&gt; foo</span></span><br></pre></td></tr></table></figure><h2 id="jQuery-callback"><a href="#jQuery-callback" class="headerlink" title="jQuery(callback)"></a>jQuery(callback)</h2><p>如果传入一个函数, 则在 document 上绑定一个 ready 事件监听函数, 当 DOM 结构加载完成时执行. ready 事件的触发要早于 load 事件.</p><p>ready 事件并不是浏览器原生事件, 而是 DOMContentLoaded 事件、onreadystatechange 事件和函数 doScrollCheck() 的统称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'DOM 加载完毕'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="jQuery-jQuery-object"><a href="#jQuery-jQuery-object" class="headerlink" title="jQuery(jQuery object)"></a>jQuery(jQuery object)</h2><p>如果传入一个 jQuery 对象, 则创建该 jQuery 对象的一个副本并返回, 副本与传入的 jQuery 对象引用完全相同的 DOM 元素</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $app = $(<span class="string">'#app'</span>);</span><br><span class="line">$app.html(<span class="string">'xuxu'</span>); <span class="comment">// -&gt; $('#app').html('xuxu')</span></span><br></pre></td></tr></table></figure><h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery()"></a>jQuery()</h2><p>如果不传入任何参数, 则返回一个空的 jQuery 对象, 属性 length 为 0.</p><p>这个功能可以用来复用 jQuery 对象</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;构造函数-jQuery&quot;&gt;&lt;a href=&quot;#构造函数-jQuery&quot; class=&quot;headerlink&quot; title=&quot;构造函数 jQuery&quot;&gt;&lt;/a&gt;构造函数 jQuery&lt;/h1&gt;&lt;p&gt;构造函数 jQuery 有七种用法:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;jQ
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>jQuery源码-总体架构</title>
    <link href="http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/"/>
    <id>http://yoursite.com/2020/03/23/jQuery%E6%BA%90%E7%A0%81-%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/</id>
    <published>2020-03-23T06:47:26.000Z</published>
    <updated>2021-08-09T03:02:39.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总体架构"><a href="#总体架构" class="headerlink" title="总体架构"></a>总体架构</h1><p>jQuery 的模块总体分为三大部分:</p><ul><li>入口模块(构造 jQuery 对象模块)</li><li>功能模块</li><li>底层支持模块</li></ul><p><img data-src="../images/jQuery-source-code/01%E6%80%BB%E4%BD%93%E6%9E%B6%E6%9E%84/jQuery.png" alt="模块导图"></p><h2 id="入口模块"><a href="#入口模块" class="headerlink" title="入口模块"></a>入口模块</h2><p>入口模块主要功能是构造 jQuery 对象, 如果在调用构造函数 <code>jQuery()</code> 创建 jQuery 对象时传入了选择器表达式, 则会调用功能模块中的选择器 <code>Sizzle</code> 遍历文档, 查找与之匹配的 DOM 元素, 并创建一个包含了这些 DOM 元素引用的 jQuery 对象</p><h2 id="功能模块"><a href="#功能模块" class="headerlink" title="功能模块"></a>功能模块</h2><p>在功能模块中, 事件系统提供了统一的事件绑定、响应、手动触发和移除机制, 它并没有将事件直接绑定到 DOM 元素上, 而是基于数据缓存模块来管理事件</p><h3 id="Ajax-模块"><a href="#Ajax-模块" class="headerlink" title="Ajax 模块"></a>Ajax 模块</h3><p>Ajax 模块允许从服务器上加载数据, 而不用刷新页面, 它基于异步队列模块来管理核触发回调函数</p><h3 id="动画模块"><a href="#动画模块" class="headerlink" title="动画模块"></a>动画模块</h3><p>动画模块用于向网页中添加动画效果, 它基于队列模块来管理和执行动画函数</p><h3 id="属性操作模块"><a href="#属性操作模块" class="headerlink" title="属性操作模块"></a>属性操作模块</h3><p>属性操作模块时用于对 HTML 属性和 DOM 属性进行读取、设置和移除操作</p><h3 id="DOM-遍历模块"><a href="#DOM-遍历模块" class="headerlink" title="DOM 遍历模块"></a>DOM 遍历模块</h3><p>DOM 遍历模块用于在 DOM 树中遍历父元素、子元素和兄弟元素</p><h3 id="DOM-操作模块"><a href="#DOM-操作模块" class="headerlink" title="DOM 操作模块"></a>DOM 操作模块</h3><p>DOM 操作模块用于插入、移除、复制和替换 DOM 元素</p><h3 id="样式操作模块"><a href="#样式操作模块" class="headerlink" title="样式操作模块"></a>样式操作模块</h3><p>样式操作模块用于获取计算样式或设置内联样式</p><h3 id="坐标模块"><a href="#坐标模块" class="headerlink" title="坐标模块"></a>坐标模块</h3><p>坐标模块用于读取或设置 DOM 元素的文档坐标</p><h3 id="尺寸模块"><a href="#尺寸模块" class="headerlink" title="尺寸模块"></a>尺寸模块</h3><p>尺寸模块用于获取 DOM 元素的高度和宽度</p><h2 id="底层支持模块"><a href="#底层支持模块" class="headerlink" title="底层支持模块"></a>底层支持模块</h2><p>底层支持模块又分为诸多子模块:</p><ul><li>工具方法: Utilities</li><li>回调函数列表: Callbacks Object</li><li>异步队列: Deferred Object</li><li>浏览器功能测试: Support</li><li>数据缓存: Data</li><li>队列: Queue</li><li>选择器: Sizzle</li></ul><h3 id="工具方法模块"><a href="#工具方法模块" class="headerlink" title="工具方法模块"></a>工具方法模块</h3><p>工具方法模块提供了一些编程辅助方法, 用于简化对 jQuery 对象、DOM 元素、数组、对象、字符串等的操作, 其他模块都会用到工具方法模块</p><h3 id="回调函数列表模块"><a href="#回调函数列表模块" class="headerlink" title="回调函数列表模块"></a>回调函数列表模块</h3><p>回调函数列表模块用于增强对回调函数的管理，支持添加、移除、触发、锁定、禁用回调函数等功能；</p><h3 id="异步队列模块"><a href="#异步队列模块" class="headerlink" title="异步队列模块"></a>异步队列模块</h3><p>异步队列模块用于解耦异步任务和回调函数, 他再回调列表的基础上为回调函数增加了状态, 并提供多个回调函数列表, 支持传播任意同步或异步回调函数的成功或失败状态</p><h3 id="浏览器功能测试模块"><a href="#浏览器功能测试模块" class="headerlink" title="浏览器功能测试模块"></a>浏览器功能测试模块</h3><p>浏览器功能测试模块提供了针对不同浏览器功能和 bug 的测试结果, 其他模块基于这些测试结果来解决浏览器之间的兼容性问题</p><h3 id="数据缓存模块"><a href="#数据缓存模块" class="headerlink" title="数据缓存模块"></a>数据缓存模块</h3><p>数据缓存模块用于为 DOM 元素和 JavaScript 对象附加任意类型的数据</p><h3 id="队列模块"><a href="#队列模块" class="headerlink" title="队列模块"></a>队列模块</h3><p>队列模块用于管理一组函数, 支持函数的入队核出队操作, 并确保函数按顺序执行, 它基于数据缓存模块实现</p><h3 id="选择器模块"><a href="#选择器模块" class="headerlink" title="选择器模块"></a>选择器模块</h3><p>选择器 <code>sizzle</code> 是一个纯 JavaScript 实现的 CSS 选择器引擎, 用于查找与选择表达式匹配的元素集合</p><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> jQuery = (</span><br><span class="line">    <span class="keyword">var</span> jQuery = (<span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init(selector, context, rootjQuery)</span><br><span class="line">    &#125;)()</span><br><span class="line">    <span class="keyword">return</span> jQuery</span><br><span class="line">  )()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 工具方法</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 回调函数列表</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步队列</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 浏览器功能测试</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数据缓存</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 事件系统</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 选择器</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 遍历</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// DOM 操作</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 样式操作 CSS</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 异步请求</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 动画</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 坐标</span></span><br><span class="line">  <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery</span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;总体架构&quot;&gt;&lt;a href=&quot;#总体架构&quot; class=&quot;headerlink&quot; title=&quot;总体架构&quot;&gt;&lt;/a&gt;总体架构&lt;/h1&gt;&lt;p&gt;jQuery 的模块总体分为三大部分:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;入口模块(构造 jQuery 对象模块)&lt;/li&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/categories/jQuery%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="jQuery源码" scheme="http://yoursite.com/tags/jQuery%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
</feed>
